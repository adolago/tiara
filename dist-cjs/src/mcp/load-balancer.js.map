{"version":3,"sources":["../../../src/mcp/load-balancer.ts"],"sourcesContent":["/**\n * Load balancer and rate limiting for MCP\n */\n\nimport type { MCPLoadBalancerConfig, MCPRequest, MCPResponse, MCPSession } from '../utils/types.js';\nimport type { ILogger } from '../core/logger.js';\nimport { MCPError } from '../utils/errors.js';\n\nexport interface RequestMetrics {\n  requestId: string;\n  sessionId: string;\n  method: string;\n  startTime: number;\n  endTime?: number;\n  success?: boolean;\n  error?: string;\n}\n\nexport interface LoadBalancerMetrics {\n  totalRequests: number;\n  successfulRequests: number;\n  failedRequests: number;\n  rateLimitedRequests: number;\n  averageResponseTime: number;\n  requestsPerSecond: number;\n  circuitBreakerTrips: number;\n  lastReset: Date;\n}\n\nexport interface ILoadBalancer {\n  shouldAllowRequest(session: MCPSession, request: MCPRequest): Promise<boolean>;\n  recordRequestStart(session: MCPSession, request: MCPRequest): RequestMetrics;\n  recordRequestEnd(metrics: RequestMetrics, response?: MCPResponse, error?: Error): void;\n  getMetrics(): LoadBalancerMetrics;\n  resetMetrics(): void;\n  isCircuitBreakerOpen(): boolean;\n}\n\n/**\n * Circuit breaker state\n */\nenum CircuitBreakerState {\n  CLOSED = 'closed',\n  OPEN = 'open',\n  HALF_OPEN = 'half_open',\n}\n\n/**\n * Rate limiter using token bucket algorithm\n */\nclass RateLimiter {\n  private tokens: number;\n  private lastRefill: number;\n\n  constructor(\n    private maxTokens: number,\n    private refillRate: number, // tokens per second\n  ) {\n    this.tokens = maxTokens;\n    this.lastRefill = Date.now();\n  }\n\n  tryConsume(tokens = 1): boolean {\n    this.refill();\n\n    if (this.tokens >= tokens) {\n      this.tokens -= tokens;\n      return true;\n    }\n\n    return false;\n  }\n\n  private refill(): void {\n    const now = Date.now();\n    const timePassed = (now - this.lastRefill) / 1000;\n    const tokensToAdd = Math.floor(timePassed * this.refillRate);\n\n    if (tokensToAdd > 0) {\n      this.tokens = Math.min(this.maxTokens, this.tokens + tokensToAdd);\n      this.lastRefill = now;\n    }\n  }\n\n  getTokens(): number {\n    this.refill();\n    return this.tokens;\n  }\n}\n\n/**\n * Circuit breaker implementation\n */\nclass CircuitBreaker {\n  private state = CircuitBreakerState.CLOSED;\n  private failureCount = 0;\n  private lastFailureTime = 0;\n  private successCount = 0;\n\n  constructor(\n    private failureThreshold: number,\n    private recoveryTimeout: number, // milliseconds\n    private halfOpenMaxRequests = 3,\n  ) {}\n\n  canExecute(): boolean {\n    const now = Date.now();\n\n    switch (this.state) {\n      case CircuitBreakerState.CLOSED:\n        return true;\n\n      case CircuitBreakerState.OPEN:\n        if (now - this.lastFailureTime >= this.recoveryTimeout) {\n          this.state = CircuitBreakerState.HALF_OPEN;\n          this.successCount = 0;\n          return true;\n        }\n        return false;\n\n      case CircuitBreakerState.HALF_OPEN:\n        return this.successCount < this.halfOpenMaxRequests;\n\n      default:\n        return false;\n    }\n  }\n\n  recordSuccess(): void {\n    if (this.state === CircuitBreakerState.HALF_OPEN) {\n      this.successCount++;\n      if (this.successCount >= this.halfOpenMaxRequests) {\n        this.state = CircuitBreakerState.CLOSED;\n        this.failureCount = 0;\n      }\n    } else if (this.state === CircuitBreakerState.CLOSED) {\n      this.failureCount = 0;\n    }\n  }\n\n  recordFailure(): void {\n    this.failureCount++;\n    this.lastFailureTime = Date.now();\n\n    if (this.state === CircuitBreakerState.HALF_OPEN) {\n      this.state = CircuitBreakerState.OPEN;\n    } else if (\n      this.state === CircuitBreakerState.CLOSED &&\n      this.failureCount >= this.failureThreshold\n    ) {\n      this.state = CircuitBreakerState.OPEN;\n    }\n  }\n\n  getState(): CircuitBreakerState {\n    return this.state;\n  }\n\n  getMetrics(): { state: string; failureCount: number; successCount: number } {\n    return {\n      state: this.state,\n      failureCount: this.failureCount,\n      successCount: this.successCount,\n    };\n  }\n}\n\n/**\n * Load balancer implementation\n */\nexport class LoadBalancer implements ILoadBalancer {\n  private rateLimiter: RateLimiter;\n  private circuitBreaker: CircuitBreaker;\n  private sessionRateLimiters = new Map<string, RateLimiter>();\n  private metrics: LoadBalancerMetrics;\n  private requestTimes: number[] = [];\n  private requestsInLastSecond = 0;\n  private lastSecondTimestamp = 0;\n  private cleanupInterval: ReturnType<typeof setInterval> | null = null;\n\n  constructor(\n    private config: MCPLoadBalancerConfig,\n    private logger: ILogger,\n  ) {\n    this.rateLimiter = new RateLimiter(config.maxRequestsPerSecond, config.maxRequestsPerSecond);\n\n    this.circuitBreaker = new CircuitBreaker(\n      config.circuitBreakerThreshold,\n      30000, // 30 second recovery timeout\n    );\n\n    this.metrics = {\n      totalRequests: 0,\n      successfulRequests: 0,\n      failedRequests: 0,\n      rateLimitedRequests: 0,\n      averageResponseTime: 0,\n      requestsPerSecond: 0,\n      circuitBreakerTrips: 0,\n      lastReset: new Date(),\n    };\n\n    // Clean up old session rate limiters periodically\n    this.cleanupInterval = setInterval(() => {\n      this.cleanupSessionRateLimiters();\n    }, 300000); // Every 5 minutes\n    this.cleanupInterval.unref(); // Don't prevent process exit\n  }\n\n  /** Stop the load balancer and clean up resources */\n  stop(): void {\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval);\n      this.cleanupInterval = null;\n    }\n  }\n\n  async shouldAllowRequest(session: MCPSession, request: MCPRequest): Promise<boolean> {\n    if (!this.config.enabled) {\n      return true;\n    }\n\n    // Check circuit breaker\n    if (!this.circuitBreaker.canExecute()) {\n      this.logger.warn('Request rejected by circuit breaker', {\n        sessionId: session.id,\n        method: request.method,\n        circuitState: this.circuitBreaker.getState(),\n      });\n      this.metrics.circuitBreakerTrips++;\n      return false;\n    }\n\n    // Check global rate limit\n    if (!this.rateLimiter.tryConsume()) {\n      this.logger.warn('Request rejected by global rate limiter', {\n        sessionId: session.id,\n        method: request.method,\n        remainingTokens: this.rateLimiter.getTokens(),\n      });\n      this.metrics.rateLimitedRequests++;\n      return false;\n    }\n\n    // Check per-session rate limit\n    const sessionRateLimiter = this.getSessionRateLimiter(session.id);\n    if (!sessionRateLimiter.tryConsume()) {\n      this.logger.warn('Request rejected by session rate limiter', {\n        sessionId: session.id,\n        method: request.method,\n        remainingTokens: sessionRateLimiter.getTokens(),\n      });\n      this.metrics.rateLimitedRequests++;\n      return false;\n    }\n\n    return true;\n  }\n\n  recordRequestStart(session: MCPSession, request: MCPRequest): RequestMetrics {\n    const requestMetrics: RequestMetrics = {\n      requestId: request.id.toString(),\n      sessionId: session.id,\n      method: request.method,\n      startTime: Date.now(),\n    };\n\n    this.metrics.totalRequests++;\n    this.updateRequestsPerSecond();\n\n    this.logger.debug('Request started', {\n      requestId: requestMetrics.requestId,\n      sessionId: session.id,\n      method: request.method,\n    });\n\n    return requestMetrics;\n  }\n\n  recordRequestEnd(metrics: RequestMetrics, response?: MCPResponse, error?: Error): void {\n    metrics.endTime = Date.now();\n    const duration = metrics.endTime - metrics.startTime;\n\n    // Update response time tracking\n    this.requestTimes.push(duration);\n    if (this.requestTimes.length > 1000) {\n      this.requestTimes.shift(); // Keep only last 1000 requests\n    }\n\n    const success = !error && (!response || !response.error);\n    metrics.success = success;\n    const errorMessage = error?.message || response?.error?.message;\n    if (errorMessage) {\n      metrics.error = errorMessage;\n    }\n\n    if (success) {\n      this.metrics.successfulRequests++;\n      this.circuitBreaker.recordSuccess();\n    } else {\n      this.metrics.failedRequests++;\n      this.circuitBreaker.recordFailure();\n    }\n\n    // Update average response time\n    this.metrics.averageResponseTime = this.calculateAverageResponseTime();\n\n    this.logger.debug('Request completed', {\n      requestId: metrics.requestId,\n      sessionId: metrics.sessionId,\n      method: metrics.method,\n      duration,\n      success,\n      error: metrics.error,\n    });\n  }\n\n  getMetrics(): LoadBalancerMetrics {\n    return { ...this.metrics };\n  }\n\n  resetMetrics(): void {\n    this.metrics = {\n      totalRequests: 0,\n      successfulRequests: 0,\n      failedRequests: 0,\n      rateLimitedRequests: 0,\n      averageResponseTime: 0,\n      requestsPerSecond: 0,\n      circuitBreakerTrips: 0,\n      lastReset: new Date(),\n    };\n    this.requestTimes = [];\n\n    this.logger.info('Load balancer metrics reset');\n  }\n\n  isCircuitBreakerOpen(): boolean {\n    return this.circuitBreaker.getState() === CircuitBreakerState.OPEN;\n  }\n\n  getDetailedMetrics(): {\n    loadBalancer: LoadBalancerMetrics;\n    circuitBreaker: { state: string; failureCount: number; successCount: number };\n    rateLimiter: { tokens: number; maxTokens: number };\n    sessions: number;\n  } {\n    return {\n      loadBalancer: this.getMetrics(),\n      circuitBreaker: this.circuitBreaker.getMetrics(),\n      rateLimiter: {\n        tokens: this.rateLimiter.getTokens(),\n        maxTokens: this.config.maxRequestsPerSecond,\n      },\n      sessions: this.sessionRateLimiters.size,\n    };\n  }\n\n  private getSessionRateLimiter(sessionId: string): RateLimiter {\n    let rateLimiter = this.sessionRateLimiters.get(sessionId);\n\n    if (!rateLimiter) {\n      // Create a per-session rate limiter (more restrictive than global)\n      const sessionLimit = Math.max(1, Math.floor(this.config.maxRequestsPerSecond / 10));\n      rateLimiter = new RateLimiter(sessionLimit, sessionLimit);\n      this.sessionRateLimiters.set(sessionId, rateLimiter);\n    }\n\n    return rateLimiter;\n  }\n\n  private calculateAverageResponseTime(): number {\n    if (this.requestTimes.length === 0) {\n      return 0;\n    }\n\n    const sum = this.requestTimes.reduce((acc, time) => acc + time, 0);\n    return sum / this.requestTimes.length;\n  }\n\n  private updateRequestsPerSecond(): void {\n    const now = Math.floor(Date.now() / 1000);\n\n    if (now !== this.lastSecondTimestamp) {\n      this.metrics.requestsPerSecond = this.requestsInLastSecond;\n      this.requestsInLastSecond = 1;\n      this.lastSecondTimestamp = now;\n    } else {\n      this.requestsInLastSecond++;\n    }\n  }\n\n  private cleanupSessionRateLimiters(): void {\n    // Remove rate limiters for sessions that haven't been used recently\n    const cutoffTime = Date.now() - 300000; // 5 minutes ago\n    let cleaned = 0;\n\n    for (const [sessionId, rateLimiter] of this.sessionRateLimiters.entries()) {\n      // If the rate limiter has full tokens, it hasn't been used recently\n      if (rateLimiter.getTokens() === this.config.maxRequestsPerSecond) {\n        this.sessionRateLimiters.delete(sessionId);\n        cleaned++;\n      }\n    }\n\n    if (cleaned > 0) {\n      this.logger.debug('Cleaned up session rate limiters', { count: cleaned });\n    }\n  }\n}\n\n/**\n * Request queue for handling backpressure\n */\nexport class RequestQueue {\n  private queue: Array<{\n    session: MCPSession;\n    request: MCPRequest;\n    resolve: (result: any) => void;\n    reject: (error: Error) => void;\n    timestamp: number;\n  }> = [];\n\n  private processing = false;\n  private maxQueueSize: number;\n  private requestTimeout: number;\n  private cleanupInterval: ReturnType<typeof setInterval> | null = null;\n\n  constructor(\n    maxQueueSize = 1000,\n    requestTimeout = 30000, // 30 seconds\n    private logger: ILogger,\n  ) {\n    this.maxQueueSize = maxQueueSize;\n    this.requestTimeout = requestTimeout;\n\n    // Clean up expired requests periodically\n    this.cleanupInterval = setInterval(() => {\n      this.cleanupExpiredRequests();\n    }, 10000); // Every 10 seconds\n    this.cleanupInterval.unref(); // Don't prevent process exit\n  }\n\n  /** Stop the queue and clean up resources */\n  stop(): void {\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval);\n      this.cleanupInterval = null;\n    }\n    // Reject any pending requests\n    for (const item of this.queue) {\n      item.reject(new Error('Request queue stopped'));\n    }\n    this.queue = [];\n  }\n\n  async enqueue<T>(\n    session: MCPSession,\n    request: MCPRequest,\n    processor: (session: MCPSession, request: MCPRequest) => Promise<T>,\n  ): Promise<T> {\n    if (this.queue.length >= this.maxQueueSize) {\n      throw new MCPError('Request queue is full');\n    }\n\n    return new Promise<T>((resolve, reject) => {\n      this.queue.push({\n        session,\n        request,\n        resolve,\n        reject,\n        timestamp: Date.now(),\n      });\n\n      if (!this.processing) {\n        this.processQueue(processor);\n      }\n    });\n  }\n\n  private async processQueue<T>(\n    processor: (session: MCPSession, request: MCPRequest) => Promise<T>,\n  ): Promise<void> {\n    if (this.processing) {\n      return;\n    }\n\n    this.processing = true;\n\n    while (this.queue.length > 0) {\n      const item = this.queue.shift()!;\n\n      // Check if request has expired\n      if (Date.now() - item.timestamp > this.requestTimeout) {\n        item.reject(new MCPError('Request timeout'));\n        continue;\n      }\n\n      try {\n        const result = await processor(item.session, item.request);\n        item.resolve(result);\n      } catch (error) {\n        item.reject(error instanceof Error ? error : new Error(String(error)));\n      }\n    }\n\n    this.processing = false;\n  }\n\n  private cleanupExpiredRequests(): void {\n    const now = Date.now();\n    let cleaned = 0;\n\n    this.queue = this.queue.filter((item) => {\n      if (now - item.timestamp > this.requestTimeout) {\n        item.reject(new MCPError('Request timeout'));\n        cleaned++;\n        return false;\n      }\n      return true;\n    });\n\n    if (cleaned > 0) {\n      this.logger.warn('Cleaned up expired requests from queue', { count: cleaned });\n    }\n  }\n\n  getQueueSize(): number {\n    return this.queue.length;\n  }\n\n  isProcessing(): boolean {\n    return this.processing;\n  }\n}\n"],"names":["MCPError","CircuitBreakerState","RateLimiter","tokens","lastRefill","maxTokens","refillRate","Date","now","tryConsume","refill","timePassed","tokensToAdd","Math","floor","min","getTokens","CircuitBreaker","state","failureCount","lastFailureTime","successCount","failureThreshold","recoveryTimeout","halfOpenMaxRequests","canExecute","recordSuccess","recordFailure","getState","getMetrics","LoadBalancer","rateLimiter","circuitBreaker","sessionRateLimiters","Map","metrics","requestTimes","requestsInLastSecond","lastSecondTimestamp","cleanupInterval","config","logger","maxRequestsPerSecond","circuitBreakerThreshold","totalRequests","successfulRequests","failedRequests","rateLimitedRequests","averageResponseTime","requestsPerSecond","circuitBreakerTrips","lastReset","setInterval","cleanupSessionRateLimiters","unref","stop","clearInterval","shouldAllowRequest","session","request","enabled","warn","sessionId","id","method","circuitState","remainingTokens","sessionRateLimiter","getSessionRateLimiter","recordRequestStart","requestMetrics","requestId","toString","startTime","updateRequestsPerSecond","debug","recordRequestEnd","response","error","endTime","duration","push","length","shift","success","errorMessage","message","calculateAverageResponseTime","resetMetrics","info","isCircuitBreakerOpen","getDetailedMetrics","loadBalancer","sessions","size","get","sessionLimit","max","set","sum","reduce","acc","time","cutoffTime","cleaned","entries","delete","count","RequestQueue","queue","processing","maxQueueSize","requestTimeout","cleanupExpiredRequests","item","reject","Error","enqueue","processor","Promise","resolve","timestamp","processQueue","result","String","filter","getQueueSize","isProcessing"],"mappings":"AAMA,SAASA,QAAQ,QAAQ,qBAAqB;AAmC9C,IAAA,AAAKC,6CAAAA;;;;WAAAA;EAAAA;AASL,IAAA,AAAMC,cAAN,MAAMA;;;IACIC,OAAe;IACfC,WAAmB;IAE3B,YACE,AAAQC,SAAiB,EACzB,AAAQC,UAAkB,CAC1B;aAFQD,YAAAA;aACAC,aAAAA;QAER,IAAI,CAACH,MAAM,GAAGE;QACd,IAAI,CAACD,UAAU,GAAGG,KAAKC,GAAG;IAC5B;IAEAC,WAAWN,SAAS,CAAC,EAAW;QAC9B,IAAI,CAACO,MAAM;QAEX,IAAI,IAAI,CAACP,MAAM,IAAIA,QAAQ;YACzB,IAAI,CAACA,MAAM,IAAIA;YACf,OAAO;QACT;QAEA,OAAO;IACT;IAEQO,SAAe;QACrB,MAAMF,MAAMD,KAAKC,GAAG;QACpB,MAAMG,aAAa,AAACH,CAAAA,MAAM,IAAI,CAACJ,UAAU,AAAD,IAAK;QAC7C,MAAMQ,cAAcC,KAAKC,KAAK,CAACH,aAAa,IAAI,CAACL,UAAU;QAE3D,IAAIM,cAAc,GAAG;YACnB,IAAI,CAACT,MAAM,GAAGU,KAAKE,GAAG,CAAC,IAAI,CAACV,SAAS,EAAE,IAAI,CAACF,MAAM,GAAGS;YACrD,IAAI,CAACR,UAAU,GAAGI;QACpB;IACF;IAEAQ,YAAoB;QAClB,IAAI,CAACN,MAAM;QACX,OAAO,IAAI,CAACP,MAAM;IACpB;AACF;AAKA,IAAA,AAAMc,iBAAN,MAAMA;;;;IACIC,iBAAmC;IACnCC,eAAe,EAAE;IACjBC,kBAAkB,EAAE;IACpBC,eAAe,EAAE;IAEzB,YACE,AAAQC,gBAAwB,EAChC,AAAQC,eAAuB,EAC/B,AAAQC,sBAAsB,CAAC,CAC/B;aAHQF,mBAAAA;aACAC,kBAAAA;aACAC,sBAAAA;IACP;IAEHC,aAAsB;QACpB,MAAMjB,MAAMD,KAAKC,GAAG;QAEpB,OAAQ,IAAI,CAACU,KAAK;YAChB;gBACE,OAAO;YAET;gBACE,IAAIV,MAAM,IAAI,CAACY,eAAe,IAAI,IAAI,CAACG,eAAe,EAAE;oBACtD,IAAI,CAACL,KAAK;oBACV,IAAI,CAACG,YAAY,GAAG;oBACpB,OAAO;gBACT;gBACA,OAAO;YAET;gBACE,OAAO,IAAI,CAACA,YAAY,GAAG,IAAI,CAACG,mBAAmB;YAErD;gBACE,OAAO;QACX;IACF;IAEAE,gBAAsB;QACpB,IAAI,IAAI,CAACR,KAAK,kBAAoC;YAChD,IAAI,CAACG,YAAY;YACjB,IAAI,IAAI,CAACA,YAAY,IAAI,IAAI,CAACG,mBAAmB,EAAE;gBACjD,IAAI,CAACN,KAAK;gBACV,IAAI,CAACC,YAAY,GAAG;YACtB;QACF,OAAO,IAAI,IAAI,CAACD,KAAK,eAAiC;YACpD,IAAI,CAACC,YAAY,GAAG;QACtB;IACF;IAEAQ,gBAAsB;QACpB,IAAI,CAACR,YAAY;QACjB,IAAI,CAACC,eAAe,GAAGb,KAAKC,GAAG;QAE/B,IAAI,IAAI,CAACU,KAAK,kBAAoC;YAChD,IAAI,CAACA,KAAK;QACZ,OAAO,IACL,IAAI,CAACA,KAAK,iBACV,IAAI,CAACC,YAAY,IAAI,IAAI,CAACG,gBAAgB,EAC1C;YACA,IAAI,CAACJ,KAAK;QACZ;IACF;IAEAU,WAAgC;QAC9B,OAAO,IAAI,CAACV,KAAK;IACnB;IAEAW,aAA4E;QAC1E,OAAO;YACLX,OAAO,IAAI,CAACA,KAAK;YACjBC,cAAc,IAAI,CAACA,YAAY;YAC/BE,cAAc,IAAI,CAACA,YAAY;QACjC;IACF;AACF;AAKA,OAAO,MAAMS;;;IACHC,YAAyB;IACzBC,eAA+B;IAC/BC,sBAAsB,IAAIC,MAA2B;IACrDC,QAA6B;IAC7BC,eAAyB,EAAE,CAAC;IAC5BC,uBAAuB,EAAE;IACzBC,sBAAsB,EAAE;IACxBC,kBAAyD,KAAK;IAEtE,YACE,AAAQC,MAA6B,EACrC,AAAQC,MAAe,CACvB;aAFQD,SAAAA;aACAC,SAAAA;QAER,IAAI,CAACV,WAAW,GAAG,IAAI7B,YAAYsC,OAAOE,oBAAoB,EAAEF,OAAOE,oBAAoB;QAE3F,IAAI,CAACV,cAAc,GAAG,IAAIf,eACxBuB,OAAOG,uBAAuB,EAC9B;QAGF,IAAI,CAACR,OAAO,GAAG;YACbS,eAAe;YACfC,oBAAoB;YACpBC,gBAAgB;YAChBC,qBAAqB;YACrBC,qBAAqB;YACrBC,mBAAmB;YACnBC,qBAAqB;YACrBC,WAAW,IAAI5C;QACjB;QAGA,IAAI,CAACgC,eAAe,GAAGa,YAAY;YACjC,IAAI,CAACC,0BAA0B;QACjC,GAAG;QACH,IAAI,CAACd,eAAe,CAACe,KAAK;IAC5B;IAGAC,OAAa;QACX,IAAI,IAAI,CAAChB,eAAe,EAAE;YACxBiB,cAAc,IAAI,CAACjB,eAAe;YAClC,IAAI,CAACA,eAAe,GAAG;QACzB;IACF;IAEA,MAAMkB,mBAAmBC,OAAmB,EAAEC,OAAmB,EAAoB;QACnF,IAAI,CAAC,IAAI,CAACnB,MAAM,CAACoB,OAAO,EAAE;YACxB,OAAO;QACT;QAGA,IAAI,CAAC,IAAI,CAAC5B,cAAc,CAACP,UAAU,IAAI;YACrC,IAAI,CAACgB,MAAM,CAACoB,IAAI,CAAC,uCAAuC;gBACtDC,WAAWJ,QAAQK,EAAE;gBACrBC,QAAQL,QAAQK,MAAM;gBACtBC,cAAc,IAAI,CAACjC,cAAc,CAACJ,QAAQ;YAC5C;YACA,IAAI,CAACO,OAAO,CAACe,mBAAmB;YAChC,OAAO;QACT;QAGA,IAAI,CAAC,IAAI,CAACnB,WAAW,CAACtB,UAAU,IAAI;YAClC,IAAI,CAACgC,MAAM,CAACoB,IAAI,CAAC,2CAA2C;gBAC1DC,WAAWJ,QAAQK,EAAE;gBACrBC,QAAQL,QAAQK,MAAM;gBACtBE,iBAAiB,IAAI,CAACnC,WAAW,CAACf,SAAS;YAC7C;YACA,IAAI,CAACmB,OAAO,CAACY,mBAAmB;YAChC,OAAO;QACT;QAGA,MAAMoB,qBAAqB,IAAI,CAACC,qBAAqB,CAACV,QAAQK,EAAE;QAChE,IAAI,CAACI,mBAAmB1D,UAAU,IAAI;YACpC,IAAI,CAACgC,MAAM,CAACoB,IAAI,CAAC,4CAA4C;gBAC3DC,WAAWJ,QAAQK,EAAE;gBACrBC,QAAQL,QAAQK,MAAM;gBACtBE,iBAAiBC,mBAAmBnD,SAAS;YAC/C;YACA,IAAI,CAACmB,OAAO,CAACY,mBAAmB;YAChC,OAAO;QACT;QAEA,OAAO;IACT;IAEAsB,mBAAmBX,OAAmB,EAAEC,OAAmB,EAAkB;QAC3E,MAAMW,iBAAiC;YACrCC,WAAWZ,QAAQI,EAAE,CAACS,QAAQ;YAC9BV,WAAWJ,QAAQK,EAAE;YACrBC,QAAQL,QAAQK,MAAM;YACtBS,WAAWlE,KAAKC,GAAG;QACrB;QAEA,IAAI,CAAC2B,OAAO,CAACS,aAAa;QAC1B,IAAI,CAAC8B,uBAAuB;QAE5B,IAAI,CAACjC,MAAM,CAACkC,KAAK,CAAC,mBAAmB;YACnCJ,WAAWD,eAAeC,SAAS;YACnCT,WAAWJ,QAAQK,EAAE;YACrBC,QAAQL,QAAQK,MAAM;QACxB;QAEA,OAAOM;IACT;IAEAM,iBAAiBzC,OAAuB,EAAE0C,QAAsB,EAAEC,KAAa,EAAQ;QACrF3C,QAAQ4C,OAAO,GAAGxE,KAAKC,GAAG;QAC1B,MAAMwE,WAAW7C,QAAQ4C,OAAO,GAAG5C,QAAQsC,SAAS;QAGpD,IAAI,CAACrC,YAAY,CAAC6C,IAAI,CAACD;QACvB,IAAI,IAAI,CAAC5C,YAAY,CAAC8C,MAAM,GAAG,MAAM;YACnC,IAAI,CAAC9C,YAAY,CAAC+C,KAAK;QACzB;QAEA,MAAMC,UAAU,CAACN,SAAU,CAAA,CAACD,YAAY,CAACA,SAASC,KAAK,AAAD;QACtD3C,QAAQiD,OAAO,GAAGA;QAClB,MAAMC,eAAeP,OAAOQ,WAAWT,UAAUC,OAAOQ;QACxD,IAAID,cAAc;YAChBlD,QAAQ2C,KAAK,GAAGO;QAClB;QAEA,IAAID,SAAS;YACX,IAAI,CAACjD,OAAO,CAACU,kBAAkB;YAC/B,IAAI,CAACb,cAAc,CAACN,aAAa;QACnC,OAAO;YACL,IAAI,CAACS,OAAO,CAACW,cAAc;YAC3B,IAAI,CAACd,cAAc,CAACL,aAAa;QACnC;QAGA,IAAI,CAACQ,OAAO,CAACa,mBAAmB,GAAG,IAAI,CAACuC,4BAA4B;QAEpE,IAAI,CAAC9C,MAAM,CAACkC,KAAK,CAAC,qBAAqB;YACrCJ,WAAWpC,QAAQoC,SAAS;YAC5BT,WAAW3B,QAAQ2B,SAAS;YAC5BE,QAAQ7B,QAAQ6B,MAAM;YACtBgB;YACAI;YACAN,OAAO3C,QAAQ2C,KAAK;QACtB;IACF;IAEAjD,aAAkC;QAChC,OAAO;YAAE,GAAG,IAAI,CAACM,OAAO;QAAC;IAC3B;IAEAqD,eAAqB;QACnB,IAAI,CAACrD,OAAO,GAAG;YACbS,eAAe;YACfC,oBAAoB;YACpBC,gBAAgB;YAChBC,qBAAqB;YACrBC,qBAAqB;YACrBC,mBAAmB;YACnBC,qBAAqB;YACrBC,WAAW,IAAI5C;QACjB;QACA,IAAI,CAAC6B,YAAY,GAAG,EAAE;QAEtB,IAAI,CAACK,MAAM,CAACgD,IAAI,CAAC;IACnB;IAEAC,uBAAgC;QAC9B,OAAO,IAAI,CAAC1D,cAAc,CAACJ,QAAQ;IACrC;IAEA+D,qBAKE;QACA,OAAO;YACLC,cAAc,IAAI,CAAC/D,UAAU;YAC7BG,gBAAgB,IAAI,CAACA,cAAc,CAACH,UAAU;YAC9CE,aAAa;gBACX5B,QAAQ,IAAI,CAAC4B,WAAW,CAACf,SAAS;gBAClCX,WAAW,IAAI,CAACmC,MAAM,CAACE,oBAAoB;YAC7C;YACAmD,UAAU,IAAI,CAAC5D,mBAAmB,CAAC6D,IAAI;QACzC;IACF;IAEQ1B,sBAAsBN,SAAiB,EAAe;QAC5D,IAAI/B,cAAc,IAAI,CAACE,mBAAmB,CAAC8D,GAAG,CAACjC;QAE/C,IAAI,CAAC/B,aAAa;YAEhB,MAAMiE,eAAenF,KAAKoF,GAAG,CAAC,GAAGpF,KAAKC,KAAK,CAAC,IAAI,CAAC0B,MAAM,CAACE,oBAAoB,GAAG;YAC/EX,cAAc,IAAI7B,YAAY8F,cAAcA;YAC5C,IAAI,CAAC/D,mBAAmB,CAACiE,GAAG,CAACpC,WAAW/B;QAC1C;QAEA,OAAOA;IACT;IAEQwD,+BAAuC;QAC7C,IAAI,IAAI,CAACnD,YAAY,CAAC8C,MAAM,KAAK,GAAG;YAClC,OAAO;QACT;QAEA,MAAMiB,MAAM,IAAI,CAAC/D,YAAY,CAACgE,MAAM,CAAC,CAACC,KAAKC,OAASD,MAAMC,MAAM;QAChE,OAAOH,MAAM,IAAI,CAAC/D,YAAY,CAAC8C,MAAM;IACvC;IAEQR,0BAAgC;QACtC,MAAMlE,MAAMK,KAAKC,KAAK,CAACP,KAAKC,GAAG,KAAK;QAEpC,IAAIA,QAAQ,IAAI,CAAC8B,mBAAmB,EAAE;YACpC,IAAI,CAACH,OAAO,CAACc,iBAAiB,GAAG,IAAI,CAACZ,oBAAoB;YAC1D,IAAI,CAACA,oBAAoB,GAAG;YAC5B,IAAI,CAACC,mBAAmB,GAAG9B;QAC7B,OAAO;YACL,IAAI,CAAC6B,oBAAoB;QAC3B;IACF;IAEQgB,6BAAmC;QAEzC,MAAMkD,aAAahG,KAAKC,GAAG,KAAK;QAChC,IAAIgG,UAAU;QAEd,KAAK,MAAM,CAAC1C,WAAW/B,YAAY,IAAI,IAAI,CAACE,mBAAmB,CAACwE,OAAO,GAAI;YAEzE,IAAI1E,YAAYf,SAAS,OAAO,IAAI,CAACwB,MAAM,CAACE,oBAAoB,EAAE;gBAChE,IAAI,CAACT,mBAAmB,CAACyE,MAAM,CAAC5C;gBAChC0C;YACF;QACF;QAEA,IAAIA,UAAU,GAAG;YACf,IAAI,CAAC/D,MAAM,CAACkC,KAAK,CAAC,oCAAoC;gBAAEgC,OAAOH;YAAQ;QACzE;IACF;AACF;AAKA,OAAO,MAAMI;;IACHC,QAMH,EAAE,CAAC;IAEAC,aAAa,MAAM;IACnBC,aAAqB;IACrBC,eAAuB;IACvBzE,kBAAyD,KAAK;IAEtE,YACEwE,eAAe,IAAI,EACnBC,iBAAiB,KAAK,EACtB,AAAQvE,MAAe,CACvB;aADQA,SAAAA;QAER,IAAI,CAACsE,YAAY,GAAGA;QACpB,IAAI,CAACC,cAAc,GAAGA;QAGtB,IAAI,CAACzE,eAAe,GAAGa,YAAY;YACjC,IAAI,CAAC6D,sBAAsB;QAC7B,GAAG;QACH,IAAI,CAAC1E,eAAe,CAACe,KAAK;IAC5B;IAGAC,OAAa;QACX,IAAI,IAAI,CAAChB,eAAe,EAAE;YACxBiB,cAAc,IAAI,CAACjB,eAAe;YAClC,IAAI,CAACA,eAAe,GAAG;QACzB;QAEA,KAAK,MAAM2E,QAAQ,IAAI,CAACL,KAAK,CAAE;YAC7BK,KAAKC,MAAM,CAAC,IAAIC,MAAM;QACxB;QACA,IAAI,CAACP,KAAK,GAAG,EAAE;IACjB;IAEA,MAAMQ,QACJ3D,OAAmB,EACnBC,OAAmB,EACnB2D,SAAmE,EACvD;QACZ,IAAI,IAAI,CAACT,KAAK,CAAC3B,MAAM,IAAI,IAAI,CAAC6B,YAAY,EAAE;YAC1C,MAAM,IAAI/G,SAAS;QACrB;QAEA,OAAO,IAAIuH,QAAW,CAACC,SAASL;YAC9B,IAAI,CAACN,KAAK,CAAC5B,IAAI,CAAC;gBACdvB;gBACAC;gBACA6D;gBACAL;gBACAM,WAAWlH,KAAKC,GAAG;YACrB;YAEA,IAAI,CAAC,IAAI,CAACsG,UAAU,EAAE;gBACpB,IAAI,CAACY,YAAY,CAACJ;YACpB;QACF;IACF;IAEA,MAAcI,aACZJ,SAAmE,EACpD;QACf,IAAI,IAAI,CAACR,UAAU,EAAE;YACnB;QACF;QAEA,IAAI,CAACA,UAAU,GAAG;QAElB,MAAO,IAAI,CAACD,KAAK,CAAC3B,MAAM,GAAG,EAAG;YAC5B,MAAMgC,OAAO,IAAI,CAACL,KAAK,CAAC1B,KAAK;YAG7B,IAAI5E,KAAKC,GAAG,KAAK0G,KAAKO,SAAS,GAAG,IAAI,CAACT,cAAc,EAAE;gBACrDE,KAAKC,MAAM,CAAC,IAAInH,SAAS;gBACzB;YACF;YAEA,IAAI;gBACF,MAAM2H,SAAS,MAAML,UAAUJ,KAAKxD,OAAO,EAAEwD,KAAKvD,OAAO;gBACzDuD,KAAKM,OAAO,CAACG;YACf,EAAE,OAAO7C,OAAO;gBACdoC,KAAKC,MAAM,CAACrC,iBAAiBsC,QAAQtC,QAAQ,IAAIsC,MAAMQ,OAAO9C;YAChE;QACF;QAEA,IAAI,CAACgC,UAAU,GAAG;IACpB;IAEQG,yBAA+B;QACrC,MAAMzG,MAAMD,KAAKC,GAAG;QACpB,IAAIgG,UAAU;QAEd,IAAI,CAACK,KAAK,GAAG,IAAI,CAACA,KAAK,CAACgB,MAAM,CAAC,CAACX;YAC9B,IAAI1G,MAAM0G,KAAKO,SAAS,GAAG,IAAI,CAACT,cAAc,EAAE;gBAC9CE,KAAKC,MAAM,CAAC,IAAInH,SAAS;gBACzBwG;gBACA,OAAO;YACT;YACA,OAAO;QACT;QAEA,IAAIA,UAAU,GAAG;YACf,IAAI,CAAC/D,MAAM,CAACoB,IAAI,CAAC,0CAA0C;gBAAE8C,OAAOH;YAAQ;QAC9E;IACF;IAEAsB,eAAuB;QACrB,OAAO,IAAI,CAACjB,KAAK,CAAC3B,MAAM;IAC1B;IAEA6C,eAAwB;QACtB,OAAO,IAAI,CAACjB,UAAU;IACxB;AACF"}