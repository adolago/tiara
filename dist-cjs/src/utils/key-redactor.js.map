{"version":3,"sources":["../../../src/utils/key-redactor.ts"],"sourcesContent":["/**\n * API Key Redaction Utility\n * Prevents sensitive data from leaking into logs, memory, or git commits\n */\n\nexport interface RedactionConfig {\n  patterns: RegExp[];\n  replacement: string;\n  maskLength: number;\n}\n\nexport class KeyRedactor {\n  private static readonly API_KEY_PATTERNS = [\n    // Anthropic API keys\n    /sk-ant-[a-zA-Z0-9_-]{95,}/gi,\n\n    // OpenRouter API keys\n    /sk-or-[a-zA-Z0-9_-]{32,}/gi,\n\n    // Google/Gemini API keys\n    /AIza[a-zA-Z0-9_-]{35}/gi,\n\n    // Generic API keys\n    /[a-zA-Z0-9_-]{20,}API[a-zA-Z0-9_-]{20,}/gi,\n\n    // Bearer tokens\n    /Bearer\\s+[a-zA-Z0-9_\\-\\.]{20,}/gi,\n\n    // Environment variable format\n    /([A-Z_]+_API_KEY|[A-Z_]+_TOKEN|[A-Z_]+_SECRET)=[\"']?([^\"'\\s]+)[\"']?/gi,\n\n    // Supabase keys\n    /eyJ[a-zA-Z0-9_-]*\\.eyJ[a-zA-Z0-9_-]*\\.[a-zA-Z0-9_-]*/gi,\n  ];\n\n  // Combined pattern for faster redaction\n  private static readonly COMBINED_PATTERN = new RegExp(\n    KeyRedactor.API_KEY_PATTERNS.map(p => p.source).join('|'),\n    'gi'\n  );\n\n  private static readonly SENSITIVE_FIELDS = [\n    'apiKey',\n    'api_key',\n    'token',\n    'secret',\n    'password',\n    'private_key',\n    'privateKey',\n    'accessToken',\n    'access_token',\n    'refreshToken',\n    'refresh_token',\n  ];\n\n  // Combined pattern for faster key checking\n  private static readonly SENSITIVE_KEY_PATTERN = new RegExp(\n    KeyRedactor.SENSITIVE_FIELDS.join('|'),\n    'i'\n  );\n\n  /**\n   * Redact API keys and sensitive data from text\n   */\n  static redact(text: string, showPrefix = true): string {\n    if (!text) return text;\n\n    return text.replace(this.COMBINED_PATTERN, (match) => {\n      if (showPrefix && match.length > 8) {\n        const prefix = match.substring(0, 8);\n        return `${prefix}...[REDACTED]`;\n      }\n      return '[REDACTED_API_KEY]';\n    });\n  }\n\n  /**\n   * Redact sensitive fields in objects\n   */\n  static redactObject<T extends Record<string, any>>(obj: T, deep = true): T {\n    if (!obj || typeof obj !== 'object') return obj;\n\n    // Handle array specifically to preserve type and mapping\n    if (Array.isArray(obj)) {\n      let changed = false;\n      const newArray = obj.map(item => {\n        let newItem = item;\n        if (typeof item === 'string') {\n          newItem = this.redact(item);\n        } else {\n          newItem = this.redactObject(item, deep);\n        }\n\n        if (newItem !== item) changed = true;\n        return newItem;\n      });\n      return (changed ? newArray : obj) as unknown as T;\n    }\n\n    let redacted: T | null = null;\n    const keys = Object.keys(obj);\n\n    for (const key of keys) {\n      const val = (obj as any)[key];\n      let newVal = val;\n\n      // 1. Check if key is sensitive\n      const isSensitive = typeof val === 'string' && this.SENSITIVE_KEY_PATTERN.test(key);\n\n      if (isSensitive) {\n        if (val && val.length > 8) {\n          newVal = `${val.substring(0, 4)}...[REDACTED]`;\n        } else {\n          newVal = '[REDACTED]';\n        }\n      }\n      // 2. Deep redaction\n      else if (deep && typeof val === 'object' && val !== null) {\n        newVal = this.redactObject(val, deep);\n      }\n      // 3. String content redaction\n      else if (typeof val === 'string') {\n        newVal = this.redact(val);\n      }\n\n      // If changed, ensure we have a clone\n      if (newVal !== val) {\n        if (!redacted) {\n          redacted = { ...obj };\n        }\n        (redacted as any)[key] = newVal;\n      }\n    }\n\n    return redacted || obj;\n  }\n\n  /**\n   * Sanitize text for safe logging\n   */\n  static sanitize(text: string): string {\n    return this.redact(text, true);\n  }\n\n  /**\n   * Sanitize command arguments\n   */\n  static sanitizeArgs(args: string[]): string[] {\n    return args.map(arg => {\n      // Check if arg is a flag value pair\n      if (arg.includes('key') || arg.includes('token') || arg.includes('secret')) {\n        return this.redact(arg);\n      }\n      return arg;\n    });\n  }\n\n  /**\n   * Check if text contains unredacted sensitive data\n   */\n  static containsSensitiveData(text: string): boolean {\n    // Use search instead of match to avoid allocating an array of all matches\n    // and to stop as soon as a match is found.\n    return text.search(this.COMBINED_PATTERN) !== -1;\n  }\n\n  /**\n   * Validate that text is safe for logging/storage\n   */\n  static validate(text: string): { safe: boolean; warnings: string[] } {\n    const warnings: string[] = [];\n\n    // We can still use the individual patterns for detailed warnings\n    this.API_KEY_PATTERNS.forEach((pattern, index) => {\n      // Reset lastIndex just in case, since they are global\n      pattern.lastIndex = 0;\n      if (pattern.test(text)) {\n        warnings.push(`Potential API key detected (pattern ${index + 1})`);\n      }\n    });\n\n    return {\n      safe: warnings.length === 0,\n      warnings,\n    };\n  }\n\n  /**\n   * Redact environment variables\n   */\n  static redactEnv(env: Record<string, string | undefined>): Record<string, string> {\n    const redacted: Record<string, string> = {};\n\n    Object.keys(env).forEach(key => {\n      const value = env[key];\n      if (!value) {\n        redacted[key] = '';\n        return;\n      }\n\n      const lowerKey = key.toLowerCase();\n      const isSensitive = lowerKey.includes('key') ||\n                         lowerKey.includes('token') ||\n                         lowerKey.includes('secret') ||\n                         lowerKey.includes('password');\n\n      if (isSensitive) {\n        redacted[key] = value.length > 8\n          ? `${value.substring(0, 4)}...[REDACTED]`\n          : '[REDACTED]';\n      } else {\n        redacted[key] = value;\n      }\n    });\n\n    return redacted;\n  }\n}\n\n// Export singleton instance\nexport const redactor = KeyRedactor;\n"],"names":["KeyRedactor","API_KEY_PATTERNS","COMBINED_PATTERN","RegExp","map","p","source","join","SENSITIVE_FIELDS","SENSITIVE_KEY_PATTERN","redact","text","showPrefix","replace","match","length","prefix","substring","redactObject","obj","deep","Array","isArray","changed","newArray","item","newItem","redacted","keys","Object","key","val","newVal","isSensitive","test","sanitize","sanitizeArgs","args","arg","includes","containsSensitiveData","search","validate","warnings","forEach","pattern","index","lastIndex","push","safe","redactEnv","env","value","lowerKey","toLowerCase","redactor"],"mappings":"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"}