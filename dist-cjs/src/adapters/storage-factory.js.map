{"version":3,"sources":["../../../src/adapters/storage-factory.ts"],"sourcesContent":["/**\n * Storage Factory - Unified interface for tiara storage backends.\n *\n * Provides a consistent API regardless of whether SQLite or Qdrant is used.\n * This allows gradual migration from SQLite to Qdrant.\n */\n\nimport fs from 'fs';\nimport os from 'os';\nimport path from 'path';\nimport { QdrantCoordinationAdapter, QdrantConfig, DEFAULT_QDRANT_CONFIG } from './qdrant-adapter.js';\nimport type {\n  SwarmRecord,\n  AgentRecord,\n  TaskRecord,\n  MetricRecord,\n  EventRecord,\n} from '../api/database-service.js';\n\n// =============================================================================\n// Storage Interface\n// =============================================================================\n\n/**\n * Unified storage interface implemented by both SQLite and Qdrant backends.\n */\nexport interface StorageBackend {\n  // Lifecycle\n  initialize(): Promise<void>;\n  shutdown(): Promise<void>;\n\n  // Swarm operations\n  createSwarm(swarm: Omit<SwarmRecord, 'id' | 'createdAt' | 'updatedAt'>): Promise<string>;\n  getSwarm(id: string): Promise<SwarmRecord | null>;\n  updateSwarmStatus(id: string, status: SwarmRecord['status']): Promise<void>;\n  deleteSwarm(id: string): Promise<void>;\n  listSwarms(status?: SwarmRecord['status']): Promise<SwarmRecord[]>;\n\n  // Agent operations\n  createAgent(agent: Omit<AgentRecord, 'id' | 'createdAt' | 'updatedAt'>): Promise<string>;\n  getAgent(id: string): Promise<AgentRecord | null>;\n  updateAgentStatus(id: string, status: AgentRecord['status']): Promise<void>;\n  getAgentsBySwarm(swarmId: string): Promise<AgentRecord[]>;\n  deleteAgent(id: string): Promise<void>;\n\n  // Task operations\n  createTask(task: Omit<TaskRecord, 'id' | 'createdAt' | 'updatedAt'>): Promise<string>;\n  getTask(id: string): Promise<TaskRecord | null>;\n  updateTaskStatus(id: string, status: TaskRecord['status'], result?: unknown, errorMessage?: string): Promise<void>;\n  getTasksBySwarm(swarmId: string, status?: TaskRecord['status']): Promise<TaskRecord[]>;\n  deleteTask(id: string): Promise<void>;\n\n  // Event logging\n  logEvent(event: Omit<EventRecord, 'id' | 'createdAt'>): Promise<string>;\n  getEvents(filters: {\n    swarmId?: string;\n    agentId?: string;\n    severity?: EventRecord['severity'];\n    eventType?: string;\n    since?: Date;\n  }, limit?: number): Promise<EventRecord[]>;\n\n  // Metrics\n  recordMetric(metric: Omit<MetricRecord, 'id' | 'timestamp'>): Promise<string>;\n  getMetrics(filters: {\n    swarmId?: string;\n    agentId?: string;\n    metricType?: string;\n    since?: Date;\n  }, limit?: number): Promise<MetricRecord[]>;\n\n  // Memory (key-value)\n  memoryStore(key: string, value: string, namespace?: string, options?: { ttl?: number; metadata?: Record<string, unknown> }): Promise<void>;\n  memoryGet(key: string, namespace?: string): Promise<{ value: string; metadata?: Record<string, unknown> } | null>;\n  memoryDelete(key: string, namespace?: string): Promise<void>;\n  memoryList(namespace?: string, limit?: number): Promise<Array<{ key: string; value: string; namespace: string }>>;\n\n  // Maintenance\n  cleanup(): Promise<{ expired: number; oldEvents: number }>;\n}\n\n// =============================================================================\n// Storage Configuration\n// =============================================================================\n\nexport type StorageType = 'sqlite' | 'qdrant' | 'hybrid';\n\nexport interface StorageConfig {\n  type: StorageType;\n  sqlite?: {\n    path: string;\n  };\n  qdrant?: Partial<QdrantConfig>;\n}\n\nexport const DEFAULT_STORAGE_CONFIG: StorageConfig = {\n  type: 'sqlite',\n  sqlite: {\n    path: '.swarm/memory.db',\n  },\n};\n\n// =============================================================================\n// Qdrant Backend Wrapper\n// =============================================================================\n\n/**\n * Wraps QdrantCoordinationAdapter to implement StorageBackend interface.\n */\nclass QdrantStorageBackend implements StorageBackend {\n  private adapter: QdrantCoordinationAdapter;\n\n  constructor(config?: Partial<QdrantConfig>) {\n    this.adapter = new QdrantCoordinationAdapter(config);\n  }\n\n  async initialize(): Promise<void> {\n    await this.adapter.initialize();\n  }\n\n  async shutdown(): Promise<void> {\n    // Qdrant adapter is stateless, nothing to shut down\n  }\n\n  async createSwarm(swarm: Omit<SwarmRecord, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {\n    return this.adapter.createSwarm(swarm);\n  }\n\n  async getSwarm(id: string): Promise<SwarmRecord | null> {\n    return this.adapter.getSwarm(id);\n  }\n\n  async updateSwarmStatus(id: string, status: SwarmRecord['status']): Promise<void> {\n    return this.adapter.updateSwarmStatus(id, status);\n  }\n\n  async deleteSwarm(id: string): Promise<void> {\n    return this.adapter.deleteSwarm(id);\n  }\n\n  async listSwarms(status?: SwarmRecord['status']): Promise<SwarmRecord[]> {\n    return this.adapter.listSwarms(status);\n  }\n\n  async createAgent(agent: Omit<AgentRecord, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {\n    return this.adapter.createAgent(agent);\n  }\n\n  async getAgent(id: string): Promise<AgentRecord | null> {\n    return this.adapter.getAgent(id);\n  }\n\n  async updateAgentStatus(id: string, status: AgentRecord['status']): Promise<void> {\n    return this.adapter.updateAgentStatus(id, status);\n  }\n\n  async getAgentsBySwarm(swarmId: string): Promise<AgentRecord[]> {\n    return this.adapter.getAgentsBySwarm(swarmId);\n  }\n\n  async deleteAgent(id: string): Promise<void> {\n    return this.adapter.deleteAgent(id);\n  }\n\n  async createTask(task: Omit<TaskRecord, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {\n    return this.adapter.createTask(task);\n  }\n\n  async getTask(id: string): Promise<TaskRecord | null> {\n    return this.adapter.getTask(id);\n  }\n\n  async updateTaskStatus(id: string, status: TaskRecord['status'], result?: unknown, errorMessage?: string): Promise<void> {\n    return this.adapter.updateTaskStatus(id, status, result, errorMessage);\n  }\n\n  async getTasksBySwarm(swarmId: string, status?: TaskRecord['status']): Promise<TaskRecord[]> {\n    return this.adapter.getTasksBySwarm(swarmId, status);\n  }\n\n  async deleteTask(id: string): Promise<void> {\n    return this.adapter.deleteTask(id);\n  }\n\n  async logEvent(event: Omit<EventRecord, 'id' | 'createdAt'>): Promise<string> {\n    return this.adapter.logEvent(event);\n  }\n\n  async getEvents(filters: {\n    swarmId?: string;\n    agentId?: string;\n    severity?: EventRecord['severity'];\n    eventType?: string;\n    since?: Date;\n  }, limit = 100): Promise<EventRecord[]> {\n    return this.adapter.getEvents(filters, limit);\n  }\n\n  async recordMetric(metric: Omit<MetricRecord, 'id' | 'timestamp'>): Promise<string> {\n    return this.adapter.recordMetric(metric);\n  }\n\n  async getMetrics(filters: {\n    swarmId?: string;\n    agentId?: string;\n    metricType?: string;\n    since?: Date;\n  }, limit = 100): Promise<MetricRecord[]> {\n    return this.adapter.getMetrics(filters, limit);\n  }\n\n  async memoryStore(key: string, value: string, namespace = 'default', options?: { ttl?: number; metadata?: Record<string, unknown> }): Promise<void> {\n    return this.adapter.memoryStore(key, value, namespace, options);\n  }\n\n  async memoryGet(key: string, namespace = 'default'): Promise<{ value: string; metadata?: Record<string, unknown> } | null> {\n    const entry = await this.adapter.memoryGet(key, namespace);\n    if (!entry) return null;\n    return { value: entry.value, metadata: entry.metadata };\n  }\n\n  async memoryDelete(key: string, namespace = 'default'): Promise<void> {\n    return this.adapter.memoryDelete(key, namespace);\n  }\n\n  async memoryList(namespace = 'default', limit = 100): Promise<Array<{ key: string; value: string; namespace: string }>> {\n    const entries = await this.adapter.memoryList(namespace, limit);\n    return entries.map(e => ({ key: e.key, value: e.value, namespace: e.namespace }));\n  }\n\n  async cleanup(): Promise<{ expired: number; oldEvents: number }> {\n    return this.adapter.cleanup();\n  }\n}\n\n// =============================================================================\n// Factory\n// =============================================================================\n\nlet _storage: StorageBackend | null = null;\n\n/**\n * Get the configured storage backend.\n * Creates a singleton instance based on configuration.\n */\nexport async function getStorage(config?: StorageConfig): Promise<StorageBackend> {\n  if (_storage) {\n    return _storage;\n  }\n\n  const finalConfig = config ?? getConfigFromEnv();\n\n  switch (finalConfig.type) {\n    case 'qdrant':\n      _storage = new QdrantStorageBackend(finalConfig.qdrant);\n      break;\n\n    case 'hybrid':\n      // In hybrid mode, use Qdrant but fall back to SQLite for missing data\n      // For now, just use Qdrant\n      console.warn('Hybrid mode not fully implemented, using Qdrant');\n      _storage = new QdrantStorageBackend(finalConfig.qdrant);\n      break;\n\n    case 'sqlite':\n    default:\n      // SQLite backend would need to be implemented here\n      // For now, throw an error to encourage Qdrant adoption\n      throw new Error(\n        'SQLite backend not available through storage factory. ' +\n        'Use the legacy DatabaseService directly or migrate to Qdrant.'\n      );\n  }\n\n  await _storage.initialize();\n  return _storage;\n}\n\n/**\n * Reset the storage singleton (useful for testing).\n */\nexport async function resetStorage(): Promise<void> {\n  if (_storage) {\n    await _storage.shutdown();\n    _storage = null;\n  }\n}\n\ntype AgentCoreConfig = {\n  memory?: {\n    qdrant?: {\n      url?: string;\n      apiKey?: string;\n      collection?: string;\n    };\n    qdrantUrl?: string;\n    qdrantApiKey?: string;\n    qdrantCollection?: string;\n    embedding?: {\n      dimensions?: number;\n      dimension?: number;\n    };\n  };\n  tiara?: {\n    qdrant?: {\n      url?: string;\n      apiKey?: string;\n      stateCollection?: string;\n      memoryCollection?: string;\n      coordinationCollection?: string;\n      eventsCollection?: string;\n      patternsCollection?: string;\n      embeddingDimension?: number;\n    };\n  };\n};\n\nlet cachedAgentCoreConfig: AgentCoreConfig | null | undefined;\n\nfunction sanitizeJsonc(input: string): string {\n  let output = '';\n  let inString = false;\n  let stringChar = '';\n  let escaped = false;\n  let inLineComment = false;\n  let inBlockComment = false;\n\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n    const next = input[i + 1];\n\n    if (inLineComment) {\n      if (char === '\\n') {\n        inLineComment = false;\n        output += char;\n      }\n      continue;\n    }\n\n    if (inBlockComment) {\n      if (char === '*' && next === '/') {\n        inBlockComment = false;\n        i++;\n      }\n      continue;\n    }\n\n    if (inString) {\n      output += char;\n      if (escaped) {\n        escaped = false;\n      } else if (char === '\\\\') {\n        escaped = true;\n      } else if (char === stringChar) {\n        inString = false;\n      }\n      continue;\n    }\n\n    if (char === '\"' || char === '\\'') {\n      inString = true;\n      stringChar = char;\n      output += char;\n      continue;\n    }\n\n    if (char === '/' && next === '/') {\n      inLineComment = true;\n      i++;\n      continue;\n    }\n\n    if (char === '/' && next === '*') {\n      inBlockComment = true;\n      i++;\n      continue;\n    }\n\n    output += char;\n  }\n\n  return output.replace(/,\\s*([}\\]])/g, '$1');\n}\n\nfunction loadAgentCoreConfig(): AgentCoreConfig | null {\n  if (cachedAgentCoreConfig !== undefined) {\n    return cachedAgentCoreConfig;\n  }\n\n  const configHome = process.env.XDG_CONFIG_HOME ?? path.join(os.homedir(), '.config');\n  const candidates = [\n    path.join(configHome, 'agent-core', 'agent-core.jsonc'),\n    path.join(configHome, 'agent-core', 'agent-core.json'),\n  ];\n\n  const agentCoreRoot = process.env.AGENT_CORE_ROOT;\n  if (agentCoreRoot) {\n    candidates.push(\n      path.join(agentCoreRoot, '.agent-core', 'agent-core.jsonc'),\n      path.join(agentCoreRoot, '.agent-core', 'agent-core.json'),\n    );\n  }\n\n  for (const candidate of candidates) {\n    try {\n      const contents = fs.readFileSync(candidate, 'utf8');\n      const parsed = JSON.parse(sanitizeJsonc(contents));\n      if (parsed && typeof parsed === 'object') {\n        cachedAgentCoreConfig = parsed as AgentCoreConfig;\n        return cachedAgentCoreConfig;\n      }\n    } catch {\n      continue;\n    }\n  }\n\n  cachedAgentCoreConfig = null;\n  return null;\n}\n\n/**\n * Get storage configuration from environment variables.\n */\nfunction getConfigFromEnv(): StorageConfig {\n  const agentCoreConfig = loadAgentCoreConfig();\n  const memoryQdrant = {\n    url: agentCoreConfig?.memory?.qdrant?.url ?? agentCoreConfig?.memory?.qdrantUrl,\n    apiKey: agentCoreConfig?.memory?.qdrant?.apiKey ?? agentCoreConfig?.memory?.qdrantApiKey,\n    collection: agentCoreConfig?.memory?.qdrant?.collection ?? agentCoreConfig?.memory?.qdrantCollection,\n  };\n  const memoryEmbeddingDimension =\n    agentCoreConfig?.memory?.embedding?.dimensions ??\n    agentCoreConfig?.memory?.embedding?.dimension;\n  const tiaraQdrant = agentCoreConfig?.tiara?.qdrant ?? {};\n  const configHasQdrant = Boolean(tiaraQdrant.url || memoryQdrant.url);\n\n  const type = (configHasQdrant ? 'qdrant' : 'sqlite') as StorageType;\n  const embeddingDimension =\n    tiaraQdrant.embeddingDimension ??\n    (typeof memoryEmbeddingDimension === 'number' ? memoryEmbeddingDimension : undefined) ??\n    DEFAULT_QDRANT_CONFIG.embeddingDimension;\n  const resolvedEmbeddingDimension = embeddingDimension;\n\n  return {\n    type,\n    sqlite: {\n      path: process.env.TIARA_SQLITE_PATH ?? '.swarm/memory.db',\n    },\n    qdrant: {\n      url: tiaraQdrant.url ?? memoryQdrant.url ?? DEFAULT_QDRANT_CONFIG.url,\n      apiKey: tiaraQdrant.apiKey ?? memoryQdrant.apiKey,\n      collections: {\n        coordination:\n          tiaraQdrant.coordinationCollection ??\n          tiaraQdrant.stateCollection ??\n          DEFAULT_QDRANT_CONFIG.collections.coordination,\n        events:\n          tiaraQdrant.eventsCollection ??\n          DEFAULT_QDRANT_CONFIG.collections.events,\n        patterns:\n          tiaraQdrant.patternsCollection ??\n          DEFAULT_QDRANT_CONFIG.collections.patterns,\n        memory:\n          tiaraQdrant.memoryCollection ??\n          memoryQdrant.collection ??\n          DEFAULT_QDRANT_CONFIG.collections.memory,\n      },\n      embeddingDimension: resolvedEmbeddingDimension,\n    },\n  };\n}\n\n// =============================================================================\n// Exports\n// =============================================================================\n\nexport {\n  QdrantStorageBackend,\n  QdrantCoordinationAdapter,\n  QdrantConfig,\n  DEFAULT_QDRANT_CONFIG,\n};\n"],"names":["fs","os","path","QdrantCoordinationAdapter","QdrantConfig","DEFAULT_QDRANT_CONFIG","DEFAULT_STORAGE_CONFIG","type","sqlite","QdrantStorageBackend","adapter","config","initialize","shutdown","createSwarm","swarm","getSwarm","id","updateSwarmStatus","status","deleteSwarm","listSwarms","createAgent","agent","getAgent","updateAgentStatus","getAgentsBySwarm","swarmId","deleteAgent","createTask","task","getTask","updateTaskStatus","result","errorMessage","getTasksBySwarm","deleteTask","logEvent","event","getEvents","filters","limit","recordMetric","metric","getMetrics","memoryStore","key","value","namespace","options","memoryGet","entry","metadata","memoryDelete","memoryList","entries","map","e","cleanup","_storage","getStorage","finalConfig","getConfigFromEnv","qdrant","console","warn","Error","resetStorage","cachedAgentCoreConfig","sanitizeJsonc","input","output","inString","stringChar","escaped","inLineComment","inBlockComment","i","length","char","next","replace","loadAgentCoreConfig","undefined","configHome","process","env","XDG_CONFIG_HOME","join","homedir","candidates","agentCoreRoot","AGENT_CORE_ROOT","push","candidate","contents","readFileSync","parsed","JSON","parse","agentCoreConfig","memoryQdrant","url","memory","qdrantUrl","apiKey","qdrantApiKey","collection","qdrantCollection","memoryEmbeddingDimension","embedding","dimensions","dimension","tiaraQdrant","tiara","configHasQdrant","Boolean","embeddingDimension","resolvedEmbeddingDimension","TIARA_SQLITE_PATH","collections","coordination","coordinationCollection","stateCollection","events","eventsCollection","patterns","patternsCollection","memoryCollection"],"mappings":"AAOA,OAAOA,QAAQ,KAAK;AACpB,OAAOC,QAAQ,KAAK;AACpB,OAAOC,UAAU,OAAO;AACxB,SAASC,yBAAyB,EAAEC,YAAY,EAAEC,qBAAqB,QAAQ,sBAAsB;AAqFrG,OAAO,MAAMC,yBAAwC;IACnDC,MAAM;IACNC,QAAQ;QACNN,MAAM;IACR;AACF,EAAE;AASF,IAAA,AAAMO,uBAAN,MAAMA;IACIC,QAAmC;IAE3C,YAAYC,MAA8B,CAAE;QAC1C,IAAI,CAACD,OAAO,GAAG,IAAIP,0BAA0BQ;IAC/C;IAEA,MAAMC,aAA4B;QAChC,MAAM,IAAI,CAACF,OAAO,CAACE,UAAU;IAC/B;IAEA,MAAMC,WAA0B,CAEhC;IAEA,MAAMC,YAAYC,KAA0D,EAAmB;QAC7F,OAAO,IAAI,CAACL,OAAO,CAACI,WAAW,CAACC;IAClC;IAEA,MAAMC,SAASC,EAAU,EAA+B;QACtD,OAAO,IAAI,CAACP,OAAO,CAACM,QAAQ,CAACC;IAC/B;IAEA,MAAMC,kBAAkBD,EAAU,EAAEE,MAA6B,EAAiB;QAChF,OAAO,IAAI,CAACT,OAAO,CAACQ,iBAAiB,CAACD,IAAIE;IAC5C;IAEA,MAAMC,YAAYH,EAAU,EAAiB;QAC3C,OAAO,IAAI,CAACP,OAAO,CAACU,WAAW,CAACH;IAClC;IAEA,MAAMI,WAAWF,MAA8B,EAA0B;QACvE,OAAO,IAAI,CAACT,OAAO,CAACW,UAAU,CAACF;IACjC;IAEA,MAAMG,YAAYC,KAA0D,EAAmB;QAC7F,OAAO,IAAI,CAACb,OAAO,CAACY,WAAW,CAACC;IAClC;IAEA,MAAMC,SAASP,EAAU,EAA+B;QACtD,OAAO,IAAI,CAACP,OAAO,CAACc,QAAQ,CAACP;IAC/B;IAEA,MAAMQ,kBAAkBR,EAAU,EAAEE,MAA6B,EAAiB;QAChF,OAAO,IAAI,CAACT,OAAO,CAACe,iBAAiB,CAACR,IAAIE;IAC5C;IAEA,MAAMO,iBAAiBC,OAAe,EAA0B;QAC9D,OAAO,IAAI,CAACjB,OAAO,CAACgB,gBAAgB,CAACC;IACvC;IAEA,MAAMC,YAAYX,EAAU,EAAiB;QAC3C,OAAO,IAAI,CAACP,OAAO,CAACkB,WAAW,CAACX;IAClC;IAEA,MAAMY,WAAWC,IAAwD,EAAmB;QAC1F,OAAO,IAAI,CAACpB,OAAO,CAACmB,UAAU,CAACC;IACjC;IAEA,MAAMC,QAAQd,EAAU,EAA8B;QACpD,OAAO,IAAI,CAACP,OAAO,CAACqB,OAAO,CAACd;IAC9B;IAEA,MAAMe,iBAAiBf,EAAU,EAAEE,MAA4B,EAAEc,MAAgB,EAAEC,YAAqB,EAAiB;QACvH,OAAO,IAAI,CAACxB,OAAO,CAACsB,gBAAgB,CAACf,IAAIE,QAAQc,QAAQC;IAC3D;IAEA,MAAMC,gBAAgBR,OAAe,EAAER,MAA6B,EAAyB;QAC3F,OAAO,IAAI,CAACT,OAAO,CAACyB,eAAe,CAACR,SAASR;IAC/C;IAEA,MAAMiB,WAAWnB,EAAU,EAAiB;QAC1C,OAAO,IAAI,CAACP,OAAO,CAAC0B,UAAU,CAACnB;IACjC;IAEA,MAAMoB,SAASC,KAA4C,EAAmB;QAC5E,OAAO,IAAI,CAAC5B,OAAO,CAAC2B,QAAQ,CAACC;IAC/B;IAEA,MAAMC,UAAUC,OAMf,EAAEC,QAAQ,GAAG,EAA0B;QACtC,OAAO,IAAI,CAAC/B,OAAO,CAAC6B,SAAS,CAACC,SAASC;IACzC;IAEA,MAAMC,aAAaC,MAA8C,EAAmB;QAClF,OAAO,IAAI,CAACjC,OAAO,CAACgC,YAAY,CAACC;IACnC;IAEA,MAAMC,WAAWJ,OAKhB,EAAEC,QAAQ,GAAG,EAA2B;QACvC,OAAO,IAAI,CAAC/B,OAAO,CAACkC,UAAU,CAACJ,SAASC;IAC1C;IAEA,MAAMI,YAAYC,GAAW,EAAEC,KAAa,EAAEC,YAAY,SAAS,EAAEC,OAA8D,EAAiB;QAClJ,OAAO,IAAI,CAACvC,OAAO,CAACmC,WAAW,CAACC,KAAKC,OAAOC,WAAWC;IACzD;IAEA,MAAMC,UAAUJ,GAAW,EAAEE,YAAY,SAAS,EAAyE;QACzH,MAAMG,QAAQ,MAAM,IAAI,CAACzC,OAAO,CAACwC,SAAS,CAACJ,KAAKE;QAChD,IAAI,CAACG,OAAO,OAAO;QACnB,OAAO;YAAEJ,OAAOI,MAAMJ,KAAK;YAAEK,UAAUD,MAAMC,QAAQ;QAAC;IACxD;IAEA,MAAMC,aAAaP,GAAW,EAAEE,YAAY,SAAS,EAAiB;QACpE,OAAO,IAAI,CAACtC,OAAO,CAAC2C,YAAY,CAACP,KAAKE;IACxC;IAEA,MAAMM,WAAWN,YAAY,SAAS,EAAEP,QAAQ,GAAG,EAAqE;QACtH,MAAMc,UAAU,MAAM,IAAI,CAAC7C,OAAO,CAAC4C,UAAU,CAACN,WAAWP;QACzD,OAAOc,QAAQC,GAAG,CAACC,CAAAA,IAAM,CAAA;gBAAEX,KAAKW,EAAEX,GAAG;gBAAEC,OAAOU,EAAEV,KAAK;gBAAEC,WAAWS,EAAET,SAAS;YAAC,CAAA;IAChF;IAEA,MAAMU,UAA2D;QAC/D,OAAO,IAAI,CAAChD,OAAO,CAACgD,OAAO;IAC7B;AACF;AAMA,IAAIC,WAAkC;AAMtC,OAAO,eAAeC,WAAWjD,MAAsB;IACrD,IAAIgD,UAAU;QACZ,OAAOA;IACT;IAEA,MAAME,cAAclD,UAAUmD;IAE9B,OAAQD,YAAYtD,IAAI;QACtB,KAAK;YACHoD,WAAW,IAAIlD,qBAAqBoD,YAAYE,MAAM;YACtD;QAEF,KAAK;YAGHC,QAAQC,IAAI,CAAC;YACbN,WAAW,IAAIlD,qBAAqBoD,YAAYE,MAAM;YACtD;QAEF,KAAK;QACL;YAGE,MAAM,IAAIG,MACR,2DACA;IAEN;IAEA,MAAMP,SAAS/C,UAAU;IACzB,OAAO+C;AACT;AAKA,OAAO,eAAeQ;IACpB,IAAIR,UAAU;QACZ,MAAMA,SAAS9C,QAAQ;QACvB8C,WAAW;IACb;AACF;AA+BA,IAAIS;AAEJ,SAASC,cAAcC,KAAa;IAClC,IAAIC,SAAS;IACb,IAAIC,WAAW;IACf,IAAIC,aAAa;IACjB,IAAIC,UAAU;IACd,IAAIC,gBAAgB;IACpB,IAAIC,iBAAiB;IAErB,IAAK,IAAIC,IAAI,GAAGA,IAAIP,MAAMQ,MAAM,EAAED,IAAK;QACrC,MAAME,OAAOT,KAAK,CAACO,EAAE;QACrB,MAAMG,OAAOV,KAAK,CAACO,IAAI,EAAE;QAEzB,IAAIF,eAAe;YACjB,IAAII,SAAS,MAAM;gBACjBJ,gBAAgB;gBAChBJ,UAAUQ;YACZ;YACA;QACF;QAEA,IAAIH,gBAAgB;YAClB,IAAIG,SAAS,OAAOC,SAAS,KAAK;gBAChCJ,iBAAiB;gBACjBC;YACF;YACA;QACF;QAEA,IAAIL,UAAU;YACZD,UAAUQ;YACV,IAAIL,SAAS;gBACXA,UAAU;YACZ,OAAO,IAAIK,SAAS,MAAM;gBACxBL,UAAU;YACZ,OAAO,IAAIK,SAASN,YAAY;gBAC9BD,WAAW;YACb;YACA;QACF;QAEA,IAAIO,SAAS,OAAOA,SAAS,MAAM;YACjCP,WAAW;YACXC,aAAaM;YACbR,UAAUQ;YACV;QACF;QAEA,IAAIA,SAAS,OAAOC,SAAS,KAAK;YAChCL,gBAAgB;YAChBE;YACA;QACF;QAEA,IAAIE,SAAS,OAAOC,SAAS,KAAK;YAChCJ,iBAAiB;YACjBC;YACA;QACF;QAEAN,UAAUQ;IACZ;IAEA,OAAOR,OAAOU,OAAO,CAAC,gBAAgB;AACxC;AAEA,SAASC;IACP,IAAId,0BAA0Be,WAAW;QACvC,OAAOf;IACT;IAEA,MAAMgB,aAAaC,QAAQC,GAAG,CAACC,eAAe,IAAIrF,KAAKsF,IAAI,CAACvF,GAAGwF,OAAO,IAAI;IAC1E,MAAMC,aAAa;QACjBxF,KAAKsF,IAAI,CAACJ,YAAY,cAAc;QACpClF,KAAKsF,IAAI,CAACJ,YAAY,cAAc;KACrC;IAED,MAAMO,gBAAgBN,QAAQC,GAAG,CAACM,eAAe;IACjD,IAAID,eAAe;QACjBD,WAAWG,IAAI,CACb3F,KAAKsF,IAAI,CAACG,eAAe,eAAe,qBACxCzF,KAAKsF,IAAI,CAACG,eAAe,eAAe;IAE5C;IAEA,KAAK,MAAMG,aAAaJ,WAAY;QAClC,IAAI;YACF,MAAMK,WAAW/F,GAAGgG,YAAY,CAACF,WAAW;YAC5C,MAAMG,SAASC,KAAKC,KAAK,CAAC9B,cAAc0B;YACxC,IAAIE,UAAU,OAAOA,WAAW,UAAU;gBACxC7B,wBAAwB6B;gBACxB,OAAO7B;YACT;QACF,EAAE,OAAM;YACN;QACF;IACF;IAEAA,wBAAwB;IACxB,OAAO;AACT;AAKA,SAASN;IACP,MAAMsC,kBAAkBlB;IACxB,MAAMmB,eAAe;QACnBC,KAAKF,iBAAiBG,QAAQxC,QAAQuC,OAAOF,iBAAiBG,QAAQC;QACtEC,QAAQL,iBAAiBG,QAAQxC,QAAQ0C,UAAUL,iBAAiBG,QAAQG;QAC5EC,YAAYP,iBAAiBG,QAAQxC,QAAQ4C,cAAcP,iBAAiBG,QAAQK;IACtF;IACA,MAAMC,2BACJT,iBAAiBG,QAAQO,WAAWC,cACpCX,iBAAiBG,QAAQO,WAAWE;IACtC,MAAMC,cAAcb,iBAAiBc,OAAOnD,UAAU,CAAC;IACvD,MAAMoD,kBAAkBC,QAAQH,YAAYX,GAAG,IAAID,aAAaC,GAAG;IAEnE,MAAM/F,OAAQ4G,kBAAkB,WAAW;IAC3C,MAAME,qBACJJ,YAAYI,kBAAkB,IAC7B,CAAA,OAAOR,6BAA6B,WAAWA,2BAA2B1B,SAAQ,KACnF9E,sBAAsBgH,kBAAkB;IAC1C,MAAMC,6BAA6BD;IAEnC,OAAO;QACL9G;QACAC,QAAQ;YACNN,MAAMmF,QAAQC,GAAG,CAACiC,iBAAiB,IAAI;QACzC;QACAxD,QAAQ;YACNuC,KAAKW,YAAYX,GAAG,IAAID,aAAaC,GAAG,IAAIjG,sBAAsBiG,GAAG;YACrEG,QAAQQ,YAAYR,MAAM,IAAIJ,aAAaI,MAAM;YACjDe,aAAa;gBACXC,cACER,YAAYS,sBAAsB,IAClCT,YAAYU,eAAe,IAC3BtH,sBAAsBmH,WAAW,CAACC,YAAY;gBAChDG,QACEX,YAAYY,gBAAgB,IAC5BxH,sBAAsBmH,WAAW,CAACI,MAAM;gBAC1CE,UACEb,YAAYc,kBAAkB,IAC9B1H,sBAAsBmH,WAAW,CAACM,QAAQ;gBAC5CvB,QACEU,YAAYe,gBAAgB,IAC5B3B,aAAaM,UAAU,IACvBtG,sBAAsBmH,WAAW,CAACjB,MAAM;YAC5C;YACAc,oBAAoBC;QACtB;IACF;AACF;AAMA,SACE7G,oBAAoB,EACpBN,yBAAyB,EACzBC,YAAY,EACZC,qBAAqB,GACrB"}