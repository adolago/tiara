{"version":3,"sources":["../../../src/adapters/storage-factory.ts"],"sourcesContent":["/**\n * Storage Factory - Unified interface for tiara storage backends.\n *\n * Provides a consistent API regardless of whether SQLite or Qdrant is used.\n * This allows gradual migration from SQLite to Qdrant.\n */\n\nimport { QdrantCoordinationAdapter, QdrantConfig, DEFAULT_QDRANT_CONFIG } from './qdrant-adapter.js';\nimport type {\n  SwarmRecord,\n  AgentRecord,\n  TaskRecord,\n  MetricRecord,\n  EventRecord,\n} from '../api/database-service.js';\n\n// =============================================================================\n// Storage Interface\n// =============================================================================\n\n/**\n * Unified storage interface implemented by both SQLite and Qdrant backends.\n */\nexport interface StorageBackend {\n  // Lifecycle\n  initialize(): Promise<void>;\n  shutdown(): Promise<void>;\n\n  // Swarm operations\n  createSwarm(swarm: Omit<SwarmRecord, 'id' | 'createdAt' | 'updatedAt'>): Promise<string>;\n  getSwarm(id: string): Promise<SwarmRecord | null>;\n  updateSwarmStatus(id: string, status: SwarmRecord['status']): Promise<void>;\n  deleteSwarm(id: string): Promise<void>;\n  listSwarms(status?: SwarmRecord['status']): Promise<SwarmRecord[]>;\n\n  // Agent operations\n  createAgent(agent: Omit<AgentRecord, 'id' | 'createdAt' | 'updatedAt'>): Promise<string>;\n  getAgent(id: string): Promise<AgentRecord | null>;\n  updateAgentStatus(id: string, status: AgentRecord['status']): Promise<void>;\n  getAgentsBySwarm(swarmId: string): Promise<AgentRecord[]>;\n  deleteAgent(id: string): Promise<void>;\n\n  // Task operations\n  createTask(task: Omit<TaskRecord, 'id' | 'createdAt' | 'updatedAt'>): Promise<string>;\n  getTask(id: string): Promise<TaskRecord | null>;\n  updateTaskStatus(id: string, status: TaskRecord['status'], result?: unknown, errorMessage?: string): Promise<void>;\n  getTasksBySwarm(swarmId: string, status?: TaskRecord['status']): Promise<TaskRecord[]>;\n  deleteTask(id: string): Promise<void>;\n\n  // Event logging\n  logEvent(event: Omit<EventRecord, 'id' | 'createdAt'>): Promise<string>;\n  getEvents(filters: {\n    swarmId?: string;\n    agentId?: string;\n    severity?: EventRecord['severity'];\n    eventType?: string;\n    since?: Date;\n  }, limit?: number): Promise<EventRecord[]>;\n\n  // Metrics\n  recordMetric(metric: Omit<MetricRecord, 'id' | 'timestamp'>): Promise<string>;\n  getMetrics(filters: {\n    swarmId?: string;\n    agentId?: string;\n    metricType?: string;\n    since?: Date;\n  }, limit?: number): Promise<MetricRecord[]>;\n\n  // Memory (key-value)\n  memoryStore(key: string, value: string, namespace?: string, options?: { ttl?: number; metadata?: Record<string, unknown> }): Promise<void>;\n  memoryGet(key: string, namespace?: string): Promise<{ value: string; metadata?: Record<string, unknown> } | null>;\n  memoryDelete(key: string, namespace?: string): Promise<void>;\n  memoryList(namespace?: string, limit?: number): Promise<Array<{ key: string; value: string; namespace: string }>>;\n\n  // Maintenance\n  cleanup(): Promise<{ expired: number; oldEvents: number }>;\n}\n\n// =============================================================================\n// Storage Configuration\n// =============================================================================\n\nexport type StorageType = 'sqlite' | 'qdrant' | 'hybrid';\n\nexport interface StorageConfig {\n  type: StorageType;\n  sqlite?: {\n    path: string;\n  };\n  qdrant?: Partial<QdrantConfig>;\n}\n\nexport const DEFAULT_STORAGE_CONFIG: StorageConfig = {\n  type: 'sqlite',\n  sqlite: {\n    path: '.swarm/memory.db',\n  },\n};\n\n// =============================================================================\n// Qdrant Backend Wrapper\n// =============================================================================\n\n/**\n * Wraps QdrantCoordinationAdapter to implement StorageBackend interface.\n */\nclass QdrantStorageBackend implements StorageBackend {\n  private adapter: QdrantCoordinationAdapter;\n\n  constructor(config?: Partial<QdrantConfig>) {\n    this.adapter = new QdrantCoordinationAdapter(config);\n  }\n\n  async initialize(): Promise<void> {\n    await this.adapter.initialize();\n  }\n\n  async shutdown(): Promise<void> {\n    // Qdrant adapter is stateless, nothing to shut down\n  }\n\n  async createSwarm(swarm: Omit<SwarmRecord, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {\n    return this.adapter.createSwarm(swarm);\n  }\n\n  async getSwarm(id: string): Promise<SwarmRecord | null> {\n    return this.adapter.getSwarm(id);\n  }\n\n  async updateSwarmStatus(id: string, status: SwarmRecord['status']): Promise<void> {\n    return this.adapter.updateSwarmStatus(id, status);\n  }\n\n  async deleteSwarm(id: string): Promise<void> {\n    return this.adapter.deleteSwarm(id);\n  }\n\n  async listSwarms(status?: SwarmRecord['status']): Promise<SwarmRecord[]> {\n    return this.adapter.listSwarms(status);\n  }\n\n  async createAgent(agent: Omit<AgentRecord, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {\n    return this.adapter.createAgent(agent);\n  }\n\n  async getAgent(id: string): Promise<AgentRecord | null> {\n    return this.adapter.getAgent(id);\n  }\n\n  async updateAgentStatus(id: string, status: AgentRecord['status']): Promise<void> {\n    return this.adapter.updateAgentStatus(id, status);\n  }\n\n  async getAgentsBySwarm(swarmId: string): Promise<AgentRecord[]> {\n    return this.adapter.getAgentsBySwarm(swarmId);\n  }\n\n  async deleteAgent(id: string): Promise<void> {\n    return this.adapter.deleteAgent(id);\n  }\n\n  async createTask(task: Omit<TaskRecord, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {\n    return this.adapter.createTask(task);\n  }\n\n  async getTask(id: string): Promise<TaskRecord | null> {\n    return this.adapter.getTask(id);\n  }\n\n  async updateTaskStatus(id: string, status: TaskRecord['status'], result?: unknown, errorMessage?: string): Promise<void> {\n    return this.adapter.updateTaskStatus(id, status, result, errorMessage);\n  }\n\n  async getTasksBySwarm(swarmId: string, status?: TaskRecord['status']): Promise<TaskRecord[]> {\n    return this.adapter.getTasksBySwarm(swarmId, status);\n  }\n\n  async deleteTask(id: string): Promise<void> {\n    return this.adapter.deleteTask(id);\n  }\n\n  async logEvent(event: Omit<EventRecord, 'id' | 'createdAt'>): Promise<string> {\n    return this.adapter.logEvent(event);\n  }\n\n  async getEvents(filters: {\n    swarmId?: string;\n    agentId?: string;\n    severity?: EventRecord['severity'];\n    eventType?: string;\n    since?: Date;\n  }, limit = 100): Promise<EventRecord[]> {\n    return this.adapter.getEvents(filters, limit);\n  }\n\n  async recordMetric(metric: Omit<MetricRecord, 'id' | 'timestamp'>): Promise<string> {\n    return this.adapter.recordMetric(metric);\n  }\n\n  async getMetrics(filters: {\n    swarmId?: string;\n    agentId?: string;\n    metricType?: string;\n    since?: Date;\n  }, limit = 100): Promise<MetricRecord[]> {\n    return this.adapter.getMetrics(filters, limit);\n  }\n\n  async memoryStore(key: string, value: string, namespace = 'default', options?: { ttl?: number; metadata?: Record<string, unknown> }): Promise<void> {\n    return this.adapter.memoryStore(key, value, namespace, options);\n  }\n\n  async memoryGet(key: string, namespace = 'default'): Promise<{ value: string; metadata?: Record<string, unknown> } | null> {\n    const entry = await this.adapter.memoryGet(key, namespace);\n    if (!entry) return null;\n    return { value: entry.value, metadata: entry.metadata };\n  }\n\n  async memoryDelete(key: string, namespace = 'default'): Promise<void> {\n    return this.adapter.memoryDelete(key, namespace);\n  }\n\n  async memoryList(namespace = 'default', limit = 100): Promise<Array<{ key: string; value: string; namespace: string }>> {\n    const entries = await this.adapter.memoryList(namespace, limit);\n    return entries.map(e => ({ key: e.key, value: e.value, namespace: e.namespace }));\n  }\n\n  async cleanup(): Promise<{ expired: number; oldEvents: number }> {\n    return this.adapter.cleanup();\n  }\n}\n\n// =============================================================================\n// Factory\n// =============================================================================\n\nlet _storage: StorageBackend | null = null;\n\n/**\n * Get the configured storage backend.\n * Creates a singleton instance based on configuration.\n */\nexport async function getStorage(config?: StorageConfig): Promise<StorageBackend> {\n  if (_storage) {\n    return _storage;\n  }\n\n  const finalConfig = config ?? getConfigFromEnv();\n\n  switch (finalConfig.type) {\n    case 'qdrant':\n      _storage = new QdrantStorageBackend(finalConfig.qdrant);\n      break;\n\n    case 'hybrid':\n      // In hybrid mode, use Qdrant but fall back to SQLite for missing data\n      // For now, just use Qdrant\n      console.warn('Hybrid mode not fully implemented, using Qdrant');\n      _storage = new QdrantStorageBackend(finalConfig.qdrant);\n      break;\n\n    case 'sqlite':\n    default:\n      // SQLite backend would need to be implemented here\n      // For now, throw an error to encourage Qdrant adoption\n      throw new Error(\n        'SQLite backend not available through storage factory. ' +\n        'Use the legacy DatabaseService directly or migrate to Qdrant.'\n      );\n  }\n\n  await _storage.initialize();\n  return _storage;\n}\n\n/**\n * Reset the storage singleton (useful for testing).\n */\nexport async function resetStorage(): Promise<void> {\n  if (_storage) {\n    await _storage.shutdown();\n    _storage = null;\n  }\n}\n\n/**\n * Get storage configuration from environment variables.\n */\nfunction getConfigFromEnv(): StorageConfig {\n  const type = (process.env.TIARA_STORAGE_TYPE ?? 'sqlite') as StorageType;\n\n  return {\n    type,\n    sqlite: {\n      path: process.env.TIARA_SQLITE_PATH ?? '.swarm/memory.db',\n    },\n    qdrant: {\n      url: process.env.TIARA_QDRANT_URL ?? DEFAULT_QDRANT_CONFIG.url,\n      apiKey: process.env.TIARA_QDRANT_API_KEY,\n      collections: {\n        coordination: process.env.TIARA_QDRANT_COORDINATION_COLLECTION ?? DEFAULT_QDRANT_CONFIG.collections.coordination,\n        events: process.env.TIARA_QDRANT_EVENTS_COLLECTION ?? DEFAULT_QDRANT_CONFIG.collections.events,\n        patterns: process.env.TIARA_QDRANT_PATTERNS_COLLECTION ?? DEFAULT_QDRANT_CONFIG.collections.patterns,\n        memory: process.env.TIARA_QDRANT_MEMORY_COLLECTION ?? DEFAULT_QDRANT_CONFIG.collections.memory,\n      },\n      embeddingDimension: parseInt(process.env.TIARA_EMBEDDING_DIMENSION ?? '384', 10),\n    },\n  };\n}\n\n// =============================================================================\n// Exports\n// =============================================================================\n\nexport {\n  QdrantStorageBackend,\n  QdrantCoordinationAdapter,\n  QdrantConfig,\n  DEFAULT_QDRANT_CONFIG,\n};\n"],"names":["QdrantCoordinationAdapter","QdrantConfig","DEFAULT_QDRANT_CONFIG","DEFAULT_STORAGE_CONFIG","type","sqlite","path","QdrantStorageBackend","adapter","config","initialize","shutdown","createSwarm","swarm","getSwarm","id","updateSwarmStatus","status","deleteSwarm","listSwarms","createAgent","agent","getAgent","updateAgentStatus","getAgentsBySwarm","swarmId","deleteAgent","createTask","task","getTask","updateTaskStatus","result","errorMessage","getTasksBySwarm","deleteTask","logEvent","event","getEvents","filters","limit","recordMetric","metric","getMetrics","memoryStore","key","value","namespace","options","memoryGet","entry","metadata","memoryDelete","memoryList","entries","map","e","cleanup","_storage","getStorage","finalConfig","getConfigFromEnv","qdrant","console","warn","Error","resetStorage","process","env","TIARA_STORAGE_TYPE","TIARA_SQLITE_PATH","url","TIARA_QDRANT_URL","apiKey","TIARA_QDRANT_API_KEY","collections","coordination","TIARA_QDRANT_COORDINATION_COLLECTION","events","TIARA_QDRANT_EVENTS_COLLECTION","patterns","TIARA_QDRANT_PATTERNS_COLLECTION","memory","TIARA_QDRANT_MEMORY_COLLECTION","embeddingDimension","parseInt","TIARA_EMBEDDING_DIMENSION"],"mappings":"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"}