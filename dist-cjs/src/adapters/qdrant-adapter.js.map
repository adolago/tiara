{"version":3,"sources":["../../../src/adapters/qdrant-adapter.ts"],"sourcesContent":["/**\n * Qdrant adapter for tiara coordination storage.\n * Migrates tiara's SQLite-based storage to Qdrant for unified memory.\n *\n * Uses Qdrant REST API directly - no additional dependencies beyond fetch.\n */\n\nimport { nanoid } from 'nanoid';\nimport type {\n  SwarmRecord,\n  AgentRecord,\n  TaskRecord,\n  MetricRecord,\n  EventRecord,\n} from '../api/database-service.js';\n\n// =============================================================================\n// Configuration\n// =============================================================================\n\nexport interface QdrantConfig {\n  url: string;\n  apiKey?: string;\n  collections: {\n    coordination: string;\n    events: string;\n    patterns: string;\n    memory: string;\n  };\n  embeddingDimension: number;\n}\n\nexport const DEFAULT_QDRANT_CONFIG: QdrantConfig = {\n  url: 'http://localhost:6333',\n  collections: {\n    coordination: 'tiara_coordination',\n    events: 'tiara_events',\n    patterns: 'tiara_patterns',\n    memory: 'tiara_memory',\n  },\n  embeddingDimension: 384, // Default for local embeddings\n};\n\n// =============================================================================\n// Types\n// =============================================================================\n\ntype QdrantCondition = {\n  key?: string;\n  match?: { value: string | number | boolean };\n  range?: { lt?: number; gt?: number; lte?: number; gte?: number };\n  is_null?: { key: string };\n  should?: QdrantCondition[];\n};\n\ntype QdrantFilter = {\n  must?: QdrantCondition[];\n  should?: QdrantCondition[];\n  must_not?: QdrantCondition[];\n};\n\ntype QdrantSearchResult = {\n  id: string;\n  score: number;\n  payload: Record<string, unknown>;\n  vector?: number[];\n};\n\ntype QdrantScrollResult = {\n  points: Array<{\n    id: string;\n    payload: Record<string, unknown>;\n    vector?: number[];\n  }>;\n  next_page_offset?: string | number | null;\n};\n\n/** Entity types stored in coordination collection */\nexport type CoordinationEntityType = 'swarm' | 'agent' | 'task' | 'resource' | 'assignment';\n\n/** Memory entry for key-value storage */\nexport interface MemoryEntry {\n  id: string;\n  key: string;\n  value: string;\n  namespace: string;\n  metadata?: Record<string, unknown>;\n  createdAt: number;\n  updatedAt: number;\n  accessedAt: number;\n  accessCount: number;\n  ttl?: number;\n  expiresAt?: number;\n}\n\n/** Pattern entry for learned behaviors */\nexport interface PatternEntry {\n  id: string;\n  patternType: 'code' | 'error' | 'behavior' | 'success';\n  content: string;\n  context: Record<string, unknown>;\n  effectiveness: number;\n  occurrences: number;\n  createdAt: number;\n  updatedAt: number;\n}\n\n// =============================================================================\n// Qdrant Coordination Adapter\n// =============================================================================\n\n/**\n * Qdrant-based storage adapter for tiara coordination.\n * Replaces SQLite storage with Qdrant vector database.\n */\nexport class QdrantCoordinationAdapter {\n  private readonly baseUrl: string;\n  private readonly apiKey?: string;\n  private readonly collections: QdrantConfig['collections'];\n  private readonly embeddingDimension: number;\n  private initialized = false;\n\n  constructor(config: Partial<QdrantConfig> = {}) {\n    const fullConfig = { ...DEFAULT_QDRANT_CONFIG, ...config };\n    this.baseUrl = fullConfig.url.replace(/\\/$/, '');\n    this.apiKey = fullConfig.apiKey;\n    this.collections = { ...DEFAULT_QDRANT_CONFIG.collections, ...config.collections };\n    this.embeddingDimension = fullConfig.embeddingDimension;\n  }\n\n  // ===========================================================================\n  // Low-level Qdrant API\n  // ===========================================================================\n\n  private async request<T>(method: string, path: string, body?: unknown): Promise<T> {\n    const headers: Record<string, string> = {\n      'Content-Type': 'application/json',\n    };\n    if (this.apiKey) {\n      headers['api-key'] = this.apiKey;\n    }\n\n    const response = await fetch(`${this.baseUrl}${path}`, {\n      method,\n      headers,\n      body: body ? JSON.stringify(body) : undefined,\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(`Qdrant ${method} ${path} failed (${response.status}): ${errorText}`);\n    }\n\n    const data = await response.json();\n    return (data as { result?: T }).result ?? (data as T);\n  }\n\n  private async collectionExists(name: string): Promise<boolean> {\n    try {\n      await this.request('GET', `/collections/${name}`);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  private async ensureCollection(name: string, indexes: Array<{ field: string; schema: unknown }>): Promise<void> {\n    const exists = await this.collectionExists(name);\n    if (exists) return;\n\n    await this.request('PUT', `/collections/${name}`, {\n      vectors: {\n        size: this.embeddingDimension,\n        distance: 'Cosine',\n      },\n    });\n\n    // Create payload indexes\n    for (const { field, schema } of indexes) {\n      try {\n        await this.request('PUT', `/collections/${name}/index`, {\n          field_name: field,\n          field_schema: schema,\n        });\n      } catch (e) {\n        // Index might already exist\n        console.warn(`Failed to create index ${field} on ${name}:`, e);\n      }\n    }\n  }\n\n  // ===========================================================================\n  // Initialization\n  // ===========================================================================\n\n  async initialize(): Promise<void> {\n    if (this.initialized) return;\n\n    // Create coordination collection\n    await this.ensureCollection(this.collections.coordination, [\n      { field: 'entityType', schema: 'keyword' },\n      { field: 'status', schema: 'keyword' },\n      { field: 'swarmId', schema: 'keyword' },\n      { field: 'agentId', schema: 'keyword' },\n      { field: 'createdAt', schema: { type: 'integer', lookup: true, range: true } },\n      { field: 'updatedAt', schema: { type: 'integer', lookup: true, range: true } },\n    ]);\n\n    // Create events collection\n    await this.ensureCollection(this.collections.events, [\n      { field: 'severity', schema: 'keyword' },\n      { field: 'eventType', schema: 'keyword' },\n      { field: 'swarmId', schema: 'keyword' },\n      { field: 'agentId', schema: 'keyword' },\n      { field: 'createdAt', schema: { type: 'integer', lookup: true, range: true } },\n    ]);\n\n    // Create patterns collection\n    await this.ensureCollection(this.collections.patterns, [\n      { field: 'patternType', schema: 'keyword' },\n      { field: 'effectiveness', schema: { type: 'float', lookup: true, range: true } },\n      { field: 'occurrences', schema: { type: 'integer', lookup: true, range: true } },\n      { field: 'createdAt', schema: { type: 'integer', lookup: true, range: true } },\n    ]);\n\n    // Create memory collection\n    await this.ensureCollection(this.collections.memory, [\n      { field: 'namespace', schema: 'keyword' },\n      { field: 'key', schema: 'keyword' },\n      { field: 'expiresAt', schema: { type: 'integer', lookup: true, range: true } },\n      { field: 'accessedAt', schema: { type: 'integer', lookup: true, range: true } },\n    ]);\n\n    this.initialized = true;\n  }\n\n  // ===========================================================================\n  // Helper Methods\n  // ===========================================================================\n\n  /** Generate a deterministic UUID from a string (for fixed-ID points) */\n  private stringToUuid(str: string): string {\n    // Simple hash-based UUID generation\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n      const char = str.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash;\n    }\n    const hex = Math.abs(hash).toString(16).padStart(8, '0');\n    return `${hex.slice(0, 8)}-${hex.slice(0, 4)}-4${hex.slice(1, 4)}-8${hex.slice(0, 3)}-${hex.padEnd(12, '0').slice(0, 12)}`;\n  }\n\n  /** Create a zero vector for non-semantic storage */\n  private zeroVector(): number[] {\n    return new Array(this.embeddingDimension).fill(0);\n  }\n\n  /** Upsert a point to a collection */\n  private async upsert(\n    collection: string,\n    id: string,\n    payload: Record<string, unknown>,\n    vector?: number[]\n  ): Promise<void> {\n    await this.request('PUT', `/collections/${collection}/points`, {\n      points: [\n        {\n          id,\n          vector: vector ?? this.zeroVector(),\n          payload,\n        },\n      ],\n    });\n  }\n\n  /** Get a point by ID */\n  private async getPoint(collection: string, id: string): Promise<Record<string, unknown> | null> {\n    try {\n      const result = await this.request<{ id: string; payload: Record<string, unknown> }[]>(\n        'POST',\n        `/collections/${collection}/points`,\n        { ids: [id], with_payload: true }\n      );\n      return result[0]?.payload ?? null;\n    } catch {\n      return null;\n    }\n  }\n\n  /** Delete points by IDs */\n  private async deletePoints(collection: string, ids: string[]): Promise<void> {\n    await this.request('POST', `/collections/${collection}/points/delete`, {\n      points: ids,\n    });\n  }\n\n  /** Search with filter */\n  private async search(\n    collection: string,\n    vector: number[],\n    filter?: QdrantFilter,\n    limit = 10\n  ): Promise<QdrantSearchResult[]> {\n    return this.request<QdrantSearchResult[]>('POST', `/collections/${collection}/points/search`, {\n      vector,\n      filter,\n      limit,\n      with_payload: true,\n    });\n  }\n\n  /** Scroll through points with filter */\n  private async scroll(\n    collection: string,\n    filter?: QdrantFilter,\n    limit = 100,\n    offset?: string | number\n  ): Promise<QdrantScrollResult> {\n    return this.request<QdrantScrollResult>('POST', `/collections/${collection}/points/scroll`, {\n      filter,\n      limit,\n      offset,\n      with_payload: true,\n    });\n  }\n\n  // ===========================================================================\n  // Swarm Operations\n  // ===========================================================================\n\n  async createSwarm(swarm: Omit<SwarmRecord, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {\n    const id = nanoid();\n    const now = new Date();\n\n    await this.upsert(this.collections.coordination, this.stringToUuid(id), {\n      entityType: 'swarm',\n      id,\n      name: swarm.name,\n      topology: swarm.topology,\n      maxAgents: swarm.maxAgents,\n      strategy: swarm.strategy,\n      status: swarm.status,\n      config: swarm.config ? JSON.stringify(swarm.config) : null,\n      createdAt: now.getTime(),\n      updatedAt: now.getTime(),\n      destroyedAt: swarm.destroyedAt?.getTime() ?? null,\n    });\n\n    return id;\n  }\n\n  async getSwarm(id: string): Promise<SwarmRecord | null> {\n    const payload = await this.getPoint(this.collections.coordination, this.stringToUuid(id));\n    if (!payload || payload.entityType !== 'swarm') return null;\n\n    return this.payloadToSwarmRecord(payload);\n  }\n\n  async updateSwarmStatus(id: string, status: SwarmRecord['status']): Promise<void> {\n    const existing = await this.getSwarm(id);\n    if (!existing) throw new Error(`Swarm ${id} not found`);\n\n    await this.upsert(this.collections.coordination, this.stringToUuid(id), {\n      ...this.swarmRecordToPayload(existing),\n      status,\n      updatedAt: Date.now(),\n      destroyedAt: status === 'destroyed' ? Date.now() : null,\n    });\n  }\n\n  async deleteSwarm(id: string): Promise<void> {\n    await this.deletePoints(this.collections.coordination, [this.stringToUuid(id)]);\n  }\n\n  async listSwarms(status?: SwarmRecord['status']): Promise<SwarmRecord[]> {\n    const filter: QdrantFilter = {\n      must: [{ key: 'entityType', match: { value: 'swarm' } }],\n    };\n    if (status) {\n      filter.must!.push({ key: 'status', match: { value: status } });\n    }\n\n    const result = await this.scroll(this.collections.coordination, filter);\n    return result.points.map((p) => this.payloadToSwarmRecord(p.payload));\n  }\n\n  private swarmRecordToPayload(swarm: SwarmRecord): Record<string, unknown> {\n    return {\n      entityType: 'swarm',\n      id: swarm.id,\n      name: swarm.name,\n      topology: swarm.topology,\n      maxAgents: swarm.maxAgents,\n      strategy: swarm.strategy,\n      status: swarm.status,\n      config: swarm.config ? JSON.stringify(swarm.config) : null,\n      createdAt: swarm.createdAt.getTime(),\n      updatedAt: swarm.updatedAt.getTime(),\n      destroyedAt: swarm.destroyedAt?.getTime() ?? null,\n    };\n  }\n\n  private payloadToSwarmRecord(payload: Record<string, unknown>): SwarmRecord {\n    return {\n      id: payload.id as string,\n      name: payload.name as string,\n      topology: payload.topology as SwarmRecord['topology'],\n      maxAgents: payload.maxAgents as number,\n      strategy: payload.strategy as SwarmRecord['strategy'],\n      status: payload.status as SwarmRecord['status'],\n      config: payload.config ? JSON.parse(payload.config as string) : undefined,\n      createdAt: new Date(payload.createdAt as number),\n      updatedAt: new Date(payload.updatedAt as number),\n      destroyedAt: payload.destroyedAt ? new Date(payload.destroyedAt as number) : undefined,\n    };\n  }\n\n  // ===========================================================================\n  // Agent Operations\n  // ===========================================================================\n\n  async createAgent(agent: Omit<AgentRecord, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {\n    const id = nanoid();\n    const now = new Date();\n\n    await this.upsert(this.collections.coordination, this.stringToUuid(id), {\n      entityType: 'agent',\n      id,\n      swarmId: agent.swarmId,\n      type: agent.type,\n      name: agent.name ?? null,\n      status: agent.status,\n      capabilities: agent.capabilities ? JSON.stringify(agent.capabilities) : null,\n      config: agent.config ? JSON.stringify(agent.config) : null,\n      metadata: agent.metadata ? JSON.stringify(agent.metadata) : null,\n      createdAt: now.getTime(),\n      updatedAt: now.getTime(),\n      terminatedAt: agent.terminatedAt?.getTime() ?? null,\n    });\n\n    return id;\n  }\n\n  async getAgent(id: string): Promise<AgentRecord | null> {\n    const payload = await this.getPoint(this.collections.coordination, this.stringToUuid(id));\n    if (!payload || payload.entityType !== 'agent') return null;\n\n    return this.payloadToAgentRecord(payload);\n  }\n\n  async updateAgentStatus(id: string, status: AgentRecord['status']): Promise<void> {\n    const existing = await this.getAgent(id);\n    if (!existing) throw new Error(`Agent ${id} not found`);\n\n    await this.upsert(this.collections.coordination, this.stringToUuid(id), {\n      ...this.agentRecordToPayload(existing),\n      status,\n      updatedAt: Date.now(),\n      terminatedAt: status === 'terminated' ? Date.now() : existing.terminatedAt?.getTime() ?? null,\n    });\n  }\n\n  async getAgentsBySwarm(swarmId: string): Promise<AgentRecord[]> {\n    const filter: QdrantFilter = {\n      must: [\n        { key: 'entityType', match: { value: 'agent' } },\n        { key: 'swarmId', match: { value: swarmId } },\n      ],\n    };\n\n    const result = await this.scroll(this.collections.coordination, filter);\n    return result.points.map((p) => this.payloadToAgentRecord(p.payload));\n  }\n\n  async deleteAgent(id: string): Promise<void> {\n    await this.deletePoints(this.collections.coordination, [this.stringToUuid(id)]);\n  }\n\n  private agentRecordToPayload(agent: AgentRecord): Record<string, unknown> {\n    return {\n      entityType: 'agent',\n      id: agent.id,\n      swarmId: agent.swarmId,\n      type: agent.type,\n      name: agent.name ?? null,\n      status: agent.status,\n      capabilities: agent.capabilities ? JSON.stringify(agent.capabilities) : null,\n      config: agent.config ? JSON.stringify(agent.config) : null,\n      metadata: agent.metadata ? JSON.stringify(agent.metadata) : null,\n      createdAt: agent.createdAt.getTime(),\n      updatedAt: agent.updatedAt.getTime(),\n      terminatedAt: agent.terminatedAt?.getTime() ?? null,\n    };\n  }\n\n  private payloadToAgentRecord(payload: Record<string, unknown>): AgentRecord {\n    return {\n      id: payload.id as string,\n      swarmId: payload.swarmId as string,\n      type: payload.type as string,\n      name: payload.name as string | undefined,\n      status: payload.status as AgentRecord['status'],\n      capabilities: payload.capabilities ? JSON.parse(payload.capabilities as string) : undefined,\n      config: payload.config ? JSON.parse(payload.config as string) : undefined,\n      metadata: payload.metadata ? JSON.parse(payload.metadata as string) : undefined,\n      createdAt: new Date(payload.createdAt as number),\n      updatedAt: new Date(payload.updatedAt as number),\n      terminatedAt: payload.terminatedAt ? new Date(payload.terminatedAt as number) : undefined,\n    };\n  }\n\n  // ===========================================================================\n  // Task Operations\n  // ===========================================================================\n\n  async createTask(task: Omit<TaskRecord, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {\n    const id = nanoid();\n    const now = new Date();\n\n    await this.upsert(this.collections.coordination, this.stringToUuid(id), {\n      entityType: 'task',\n      id,\n      swarmId: task.swarmId,\n      description: task.description,\n      priority: task.priority,\n      strategy: task.strategy,\n      status: task.status,\n      maxAgents: task.maxAgents ?? null,\n      requirements: task.requirements ? JSON.stringify(task.requirements) : null,\n      metadata: task.metadata ? JSON.stringify(task.metadata) : null,\n      result: task.result ? JSON.stringify(task.result) : null,\n      errorMessage: task.errorMessage ?? null,\n      assignedTo: task.assignedTo ?? null,\n      createdAt: now.getTime(),\n      updatedAt: now.getTime(),\n      startedAt: task.startedAt?.getTime() ?? null,\n      completedAt: task.completedAt?.getTime() ?? null,\n    });\n\n    return id;\n  }\n\n  async getTask(id: string): Promise<TaskRecord | null> {\n    const payload = await this.getPoint(this.collections.coordination, this.stringToUuid(id));\n    if (!payload || payload.entityType !== 'task') return null;\n\n    return this.payloadToTaskRecord(payload);\n  }\n\n  async updateTaskStatus(\n    id: string,\n    status: TaskRecord['status'],\n    result?: unknown,\n    errorMessage?: string\n  ): Promise<void> {\n    const existing = await this.getTask(id);\n    if (!existing) throw new Error(`Task ${id} not found`);\n\n    const updates: Record<string, unknown> = {\n      ...this.taskRecordToPayload(existing),\n      status,\n      updatedAt: Date.now(),\n    };\n\n    if (result !== undefined) {\n      updates.result = JSON.stringify(result);\n    }\n    if (errorMessage !== undefined) {\n      updates.errorMessage = errorMessage;\n    }\n    if (status === 'running' && !existing.startedAt) {\n      updates.startedAt = Date.now();\n    }\n    if (status === 'completed' || status === 'failed' || status === 'cancelled') {\n      updates.completedAt = Date.now();\n    }\n\n    await this.upsert(this.collections.coordination, this.stringToUuid(id), updates);\n  }\n\n  async getTasksBySwarm(swarmId: string, status?: TaskRecord['status']): Promise<TaskRecord[]> {\n    const filter: QdrantFilter = {\n      must: [\n        { key: 'entityType', match: { value: 'task' } },\n        { key: 'swarmId', match: { value: swarmId } },\n      ],\n    };\n    if (status) {\n      filter.must!.push({ key: 'status', match: { value: status } });\n    }\n\n    const result = await this.scroll(this.collections.coordination, filter);\n    return result.points.map((p) => this.payloadToTaskRecord(p.payload));\n  }\n\n  async searchTasks(query: string, embedding: number[], limit = 10): Promise<TaskRecord[]> {\n    const filter: QdrantFilter = {\n      must: [{ key: 'entityType', match: { value: 'task' } }],\n    };\n\n    const results = await this.search(this.collections.coordination, embedding, filter, limit);\n    return results.map((r) => this.payloadToTaskRecord(r.payload));\n  }\n\n  async deleteTask(id: string): Promise<void> {\n    await this.deletePoints(this.collections.coordination, [this.stringToUuid(id)]);\n  }\n\n  private taskRecordToPayload(task: TaskRecord): Record<string, unknown> {\n    return {\n      entityType: 'task',\n      id: task.id,\n      swarmId: task.swarmId,\n      description: task.description,\n      priority: task.priority,\n      strategy: task.strategy,\n      status: task.status,\n      maxAgents: task.maxAgents ?? null,\n      requirements: task.requirements ? JSON.stringify(task.requirements) : null,\n      metadata: task.metadata ? JSON.stringify(task.metadata) : null,\n      result: task.result ? JSON.stringify(task.result) : null,\n      errorMessage: task.errorMessage ?? null,\n      assignedTo: task.assignedTo ?? null,\n      createdAt: task.createdAt.getTime(),\n      updatedAt: task.updatedAt.getTime(),\n      startedAt: task.startedAt?.getTime() ?? null,\n      completedAt: task.completedAt?.getTime() ?? null,\n    };\n  }\n\n  private payloadToTaskRecord(payload: Record<string, unknown>): TaskRecord {\n    return {\n      id: payload.id as string,\n      swarmId: payload.swarmId as string,\n      description: payload.description as string,\n      priority: payload.priority as TaskRecord['priority'],\n      strategy: payload.strategy as TaskRecord['strategy'],\n      status: payload.status as TaskRecord['status'],\n      maxAgents: payload.maxAgents as number | undefined,\n      requirements: payload.requirements ? JSON.parse(payload.requirements as string) : undefined,\n      metadata: payload.metadata ? JSON.parse(payload.metadata as string) : undefined,\n      result: payload.result ? JSON.parse(payload.result as string) : undefined,\n      errorMessage: payload.errorMessage as string | undefined,\n      assignedTo: payload.assignedTo as string | undefined,\n      createdAt: new Date(payload.createdAt as number),\n      updatedAt: new Date(payload.updatedAt as number),\n      startedAt: payload.startedAt ? new Date(payload.startedAt as number) : undefined,\n      completedAt: payload.completedAt ? new Date(payload.completedAt as number) : undefined,\n    };\n  }\n\n  // ===========================================================================\n  // Event Logging\n  // ===========================================================================\n\n  async logEvent(event: Omit<EventRecord, 'id' | 'createdAt'>): Promise<string> {\n    const id = nanoid();\n    const now = new Date();\n\n    await this.upsert(this.collections.events, this.stringToUuid(id), {\n      id,\n      swarmId: event.swarmId ?? null,\n      agentId: event.agentId ?? null,\n      eventType: event.eventType,\n      eventName: event.eventName,\n      eventData: event.eventData ? JSON.stringify(event.eventData) : null,\n      severity: event.severity,\n      createdAt: now.getTime(),\n    });\n\n    return id;\n  }\n\n  async getEvents(\n    filters: {\n      swarmId?: string;\n      agentId?: string;\n      severity?: EventRecord['severity'];\n      eventType?: string;\n      since?: Date;\n    },\n    limit = 100\n  ): Promise<EventRecord[]> {\n    const must: QdrantCondition[] = [];\n\n    if (filters.swarmId) {\n      must.push({ key: 'swarmId', match: { value: filters.swarmId } });\n    }\n    if (filters.agentId) {\n      must.push({ key: 'agentId', match: { value: filters.agentId } });\n    }\n    if (filters.severity) {\n      must.push({ key: 'severity', match: { value: filters.severity } });\n    }\n    if (filters.eventType) {\n      must.push({ key: 'eventType', match: { value: filters.eventType } });\n    }\n    if (filters.since) {\n      must.push({ key: 'createdAt', range: { gte: filters.since.getTime() } });\n    }\n\n    const result = await this.scroll(\n      this.collections.events,\n      must.length > 0 ? { must } : undefined,\n      limit\n    );\n\n    return result.points.map((p) => ({\n      id: p.payload.id as string,\n      swarmId: p.payload.swarmId as string | undefined,\n      agentId: p.payload.agentId as string | undefined,\n      eventType: p.payload.eventType as string,\n      eventName: p.payload.eventName as string,\n      eventData: p.payload.eventData ? JSON.parse(p.payload.eventData as string) : undefined,\n      severity: p.payload.severity as EventRecord['severity'],\n      createdAt: new Date(p.payload.createdAt as number),\n    }));\n  }\n\n  async searchEvents(query: string, embedding: number[], limit = 10): Promise<EventRecord[]> {\n    const results = await this.search(this.collections.events, embedding, undefined, limit);\n\n    return results.map((r) => ({\n      id: r.payload.id as string,\n      swarmId: r.payload.swarmId as string | undefined,\n      agentId: r.payload.agentId as string | undefined,\n      eventType: r.payload.eventType as string,\n      eventName: r.payload.eventName as string,\n      eventData: r.payload.eventData ? JSON.parse(r.payload.eventData as string) : undefined,\n      severity: r.payload.severity as EventRecord['severity'],\n      createdAt: new Date(r.payload.createdAt as number),\n    }));\n  }\n\n  // ===========================================================================\n  // Pattern Storage (for learned behaviors)\n  // ===========================================================================\n\n  async storePattern(\n    pattern: Omit<PatternEntry, 'id' | 'createdAt' | 'updatedAt'>,\n    embedding: number[]\n  ): Promise<string> {\n    const id = nanoid();\n    const now = Date.now();\n\n    await this.upsert(\n      this.collections.patterns,\n      this.stringToUuid(id),\n      {\n        id,\n        patternType: pattern.patternType,\n        content: pattern.content,\n        context: JSON.stringify(pattern.context),\n        effectiveness: pattern.effectiveness,\n        occurrences: pattern.occurrences,\n        createdAt: now,\n        updatedAt: now,\n      },\n      embedding\n    );\n\n    return id;\n  }\n\n  async searchSimilarPatterns(embedding: number[], limit = 10): Promise<PatternEntry[]> {\n    const results = await this.search(this.collections.patterns, embedding, undefined, limit);\n\n    return results.map((r) => ({\n      id: r.payload.id as string,\n      patternType: r.payload.patternType as PatternEntry['patternType'],\n      content: r.payload.content as string,\n      context: JSON.parse(r.payload.context as string),\n      effectiveness: r.payload.effectiveness as number,\n      occurrences: r.payload.occurrences as number,\n      createdAt: r.payload.createdAt as number,\n      updatedAt: r.payload.updatedAt as number,\n    }));\n  }\n\n  async updatePatternEffectiveness(id: string, effectiveness: number, incrementOccurrences = true): Promise<void> {\n    const payload = await this.getPoint(this.collections.patterns, this.stringToUuid(id));\n    if (!payload) throw new Error(`Pattern ${id} not found`);\n\n    await this.upsert(this.collections.patterns, this.stringToUuid(id), {\n      ...payload,\n      effectiveness,\n      occurrences: incrementOccurrences ? (payload.occurrences as number) + 1 : payload.occurrences,\n      updatedAt: Date.now(),\n    });\n  }\n\n  // ===========================================================================\n  // Memory Storage (key-value with TTL)\n  // ===========================================================================\n\n  async memoryStore(\n    key: string,\n    value: string,\n    namespace = 'default',\n    options?: { ttl?: number; metadata?: Record<string, unknown> }\n  ): Promise<void> {\n    const now = Date.now();\n    const id = `${namespace}:${key}`;\n\n    const existing = await this.getPoint(this.collections.memory, this.stringToUuid(id));\n\n    await this.upsert(this.collections.memory, this.stringToUuid(id), {\n      id,\n      key,\n      value,\n      namespace,\n      metadata: options?.metadata ? JSON.stringify(options.metadata) : null,\n      createdAt: existing?.createdAt ?? now,\n      updatedAt: now,\n      accessedAt: now,\n      accessCount: ((existing?.accessCount as number) ?? 0) + 1,\n      ttl: options?.ttl ?? null,\n      expiresAt: options?.ttl ? now + options.ttl * 1000 : null,\n    });\n  }\n\n  async memoryGet(key: string, namespace = 'default'): Promise<MemoryEntry | null> {\n    const id = `${namespace}:${key}`;\n    const payload = await this.getPoint(this.collections.memory, this.stringToUuid(id));\n\n    if (!payload) return null;\n\n    // Check expiration\n    if (payload.expiresAt && (payload.expiresAt as number) < Date.now()) {\n      await this.deletePoints(this.collections.memory, [this.stringToUuid(id)]);\n      return null;\n    }\n\n    // Update access time\n    await this.upsert(this.collections.memory, this.stringToUuid(id), {\n      ...payload,\n      accessedAt: Date.now(),\n      accessCount: (payload.accessCount as number) + 1,\n    });\n\n    return {\n      id: payload.id as string,\n      key: payload.key as string,\n      value: payload.value as string,\n      namespace: payload.namespace as string,\n      metadata: payload.metadata ? JSON.parse(payload.metadata as string) : undefined,\n      createdAt: payload.createdAt as number,\n      updatedAt: payload.updatedAt as number,\n      accessedAt: payload.accessedAt as number,\n      accessCount: payload.accessCount as number,\n      ttl: payload.ttl as number | undefined,\n      expiresAt: payload.expiresAt as number | undefined,\n    };\n  }\n\n  async memoryDelete(key: string, namespace = 'default'): Promise<void> {\n    const id = `${namespace}:${key}`;\n    await this.deletePoints(this.collections.memory, [this.stringToUuid(id)]);\n  }\n\n  async memoryList(namespace = 'default', limit = 100): Promise<MemoryEntry[]> {\n    const now = Date.now();\n    const filter: QdrantFilter = {\n      must: [{ key: 'namespace', match: { value: namespace } }],\n      should: [\n        { is_null: { key: 'expiresAt' } },\n        { key: 'expiresAt', range: { gt: now } },\n      ],\n    };\n\n    const result = await this.scroll(this.collections.memory, filter, limit);\n\n    return result.points.map((p) => ({\n      id: p.payload.id as string,\n      key: p.payload.key as string,\n      value: p.payload.value as string,\n      namespace: p.payload.namespace as string,\n      metadata: p.payload.metadata ? JSON.parse(p.payload.metadata as string) : undefined,\n      createdAt: p.payload.createdAt as number,\n      updatedAt: p.payload.updatedAt as number,\n      accessedAt: p.payload.accessedAt as number,\n      accessCount: p.payload.accessCount as number,\n      ttl: p.payload.ttl as number | undefined,\n      expiresAt: p.payload.expiresAt as number | undefined,\n    }));\n  }\n\n  async memoryCleanupExpired(): Promise<number> {\n    const now = Date.now();\n    const filter: QdrantFilter = {\n      must: [{ key: 'expiresAt', range: { lt: now } }],\n    };\n\n    const result = await this.scroll(this.collections.memory, filter, 1000);\n    if (result.points.length === 0) return 0;\n\n    const ids = result.points.map((p) => this.stringToUuid(p.payload.id as string));\n    await this.deletePoints(this.collections.memory, ids);\n\n    return ids.length;\n  }\n\n  // ===========================================================================\n  // Metrics (simple append-only storage)\n  // ===========================================================================\n\n  async recordMetric(metric: Omit<MetricRecord, 'id' | 'timestamp'>): Promise<string> {\n    const id = nanoid();\n    const now = new Date();\n\n    // Store metrics in the events collection with a special type\n    await this.upsert(this.collections.events, this.stringToUuid(id), {\n      id,\n      eventType: 'metric',\n      eventName: metric.metricName,\n      swarmId: metric.swarmId ?? null,\n      agentId: metric.agentId ?? null,\n      severity: 'info',\n      eventData: JSON.stringify({\n        metricType: metric.metricType,\n        metricValue: metric.metricValue,\n        unit: metric.unit,\n        metadata: metric.metadata,\n      }),\n      createdAt: now.getTime(),\n    });\n\n    return id;\n  }\n\n  async getMetrics(\n    filters: {\n      swarmId?: string;\n      agentId?: string;\n      metricType?: string;\n      since?: Date;\n    },\n    limit = 100\n  ): Promise<MetricRecord[]> {\n    const must: QdrantCondition[] = [{ key: 'eventType', match: { value: 'metric' } }];\n\n    if (filters.swarmId) {\n      must.push({ key: 'swarmId', match: { value: filters.swarmId } });\n    }\n    if (filters.agentId) {\n      must.push({ key: 'agentId', match: { value: filters.agentId } });\n    }\n    if (filters.since) {\n      must.push({ key: 'createdAt', range: { gte: filters.since.getTime() } });\n    }\n\n    const result = await this.scroll(this.collections.events, { must }, limit);\n\n    return result.points\n      .map((p) => {\n        const data = JSON.parse(p.payload.eventData as string);\n        if (filters.metricType && data.metricType !== filters.metricType) {\n          return null;\n        }\n        return {\n          id: p.payload.id as string,\n          swarmId: p.payload.swarmId as string | undefined,\n          agentId: p.payload.agentId as string | undefined,\n          metricType: data.metricType,\n          metricName: p.payload.eventName as string,\n          metricValue: data.metricValue,\n          unit: data.unit,\n          timestamp: new Date(p.payload.createdAt as number),\n          metadata: data.metadata,\n        };\n      })\n      .filter((m): m is MetricRecord => m !== null);\n  }\n\n  // ===========================================================================\n  // Cleanup & Maintenance\n  // ===========================================================================\n\n  async cleanup(): Promise<{ expired: number; oldEvents: number }> {\n    const expired = await this.memoryCleanupExpired();\n\n    // Clean up old events (older than 30 days)\n    const thirtyDaysAgo = Date.now() - 30 * 24 * 60 * 60 * 1000;\n    const filter: QdrantFilter = {\n      must: [{ key: 'createdAt', range: { lt: thirtyDaysAgo } }],\n    };\n\n    const result = await this.scroll(this.collections.events, filter, 1000);\n    if (result.points.length > 0) {\n      const ids = result.points.map((p) => this.stringToUuid(p.payload.id as string));\n      await this.deletePoints(this.collections.events, ids);\n    }\n\n    return { expired, oldEvents: result.points.length };\n  }\n}\n\n// Export singleton factory\nlet _adapter: QdrantCoordinationAdapter | null = null;\n\nexport function getQdrantAdapter(config?: Partial<QdrantConfig>): QdrantCoordinationAdapter {\n  if (!_adapter) {\n    _adapter = new QdrantCoordinationAdapter(config);\n  }\n  return _adapter;\n}\n\nexport function resetQdrantAdapter(): void {\n  _adapter = null;\n}\n"],"names":["nanoid","DEFAULT_QDRANT_CONFIG","url","collections","coordination","events","patterns","memory","embeddingDimension","QdrantCoordinationAdapter","baseUrl","apiKey","initialized","config","fullConfig","replace","request","method","path","body","headers","response","fetch","JSON","stringify","undefined","ok","errorText","text","Error","status","data","json","result","collectionExists","name","ensureCollection","indexes","exists","vectors","size","distance","field","schema","field_name","field_schema","e","console","warn","initialize","type","lookup","range","stringToUuid","str","hash","i","length","char","charCodeAt","hex","Math","abs","toString","padStart","slice","padEnd","zeroVector","Array","fill","upsert","collection","id","payload","vector","points","getPoint","ids","with_payload","deletePoints","search","filter","limit","scroll","offset","createSwarm","swarm","now","Date","entityType","topology","maxAgents","strategy","createdAt","getTime","updatedAt","destroyedAt","getSwarm","payloadToSwarmRecord","updateSwarmStatus","existing","swarmRecordToPayload","deleteSwarm","listSwarms","must","key","match","value","push","map","p","parse","createAgent","agent","swarmId","capabilities","metadata","terminatedAt","getAgent","payloadToAgentRecord","updateAgentStatus","agentRecordToPayload","getAgentsBySwarm","deleteAgent","createTask","task","description","priority","requirements","errorMessage","assignedTo","startedAt","completedAt","getTask","payloadToTaskRecord","updateTaskStatus","updates","taskRecordToPayload","getTasksBySwarm","searchTasks","query","embedding","results","r","deleteTask","logEvent","event","agentId","eventType","eventName","eventData","severity","getEvents","filters","since","gte","searchEvents","storePattern","pattern","patternType","content","context","effectiveness","occurrences","searchSimilarPatterns","updatePatternEffectiveness","incrementOccurrences","memoryStore","namespace","options","accessedAt","accessCount","ttl","expiresAt","memoryGet","memoryDelete","memoryList","should","is_null","gt","memoryCleanupExpired","lt","recordMetric","metric","metricName","metricType","metricValue","unit","getMetrics","timestamp","m","cleanup","expired","thirtyDaysAgo","oldEvents","_adapter","getQdrantAdapter","resetQdrantAdapter"],"mappings":"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"}