{"version":3,"sources":["../../../../../src/verification/tests/integration/cross-agent-communication.test.ts"],"sourcesContent":["/**\n * Integration Tests for Cross-Agent Communication Verification\n * \n * Tests the verification of communication patterns between agents including:\n * - Message integrity verification\n * - Communication protocol validation\n * - Agent response verification\n * - Cross-verification between agents\n */\n\nimport { jest } from '@jest/globals';\nimport { EventEmitter } from 'events';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport * as os from 'os';\n\n// Mock agent types for testing\ninterface MockAgent {\n  id: string;\n  type: string;\n  capabilities: string[];\n  messageHistory: AgentMessage[];\n  verificationResults: VerificationResult[];\n  truthScore: number;\n  emit: (event: string, data: any) => void;\n  on: (event: string, callback: (data: any) => void) => void;\n}\n\ninterface AgentMessage {\n  id: string;\n  from: string;\n  to: string;\n  type: 'task' | 'result' | 'verification' | 'status';\n  content: any;\n  timestamp: number;\n  hash: string;\n}\n\ninterface VerificationResult {\n  messageId: string;\n  verifiedBy: string;\n  truthScore: number;\n  evidence: any;\n  timestamp: number;\n  conflicts: string[];\n}\n\ninterface CrossVerificationReport {\n  totalMessages: number;\n  verifiedMessages: number;\n  conflictingClaims: number;\n  avgTruthScore: number;\n  agentReliability: Map<string, number>;\n  communicationIntegrity: number;\n}\n\ndescribe('Cross-Agent Communication Verification', () => {\n  let communicationBus: EventEmitter;\n  let mockAgents: Map<string, MockAgent>;\n  let verificationSystem: CrossAgentVerificationSystem;\n  let tempDir: string;\n\n  beforeEach(async () => {\n    // Setup test environment\n    tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'cross-agent-test-'));\n    \n    communicationBus = new EventEmitter();\n    mockAgents = new Map();\n    verificationSystem = new CrossAgentVerificationSystem(communicationBus, tempDir);\n\n    // Create mock agents\n    await createMockAgents();\n    \n    // Initialize verification system\n    await verificationSystem.initialize();\n  });\n\n  afterEach(async () => {\n    await fs.rm(tempDir, { recursive: true, force: true });\n    communicationBus.removeAllListeners();\n  });\n\n  async function createMockAgents() {\n    const agentConfigs = [\n      { id: 'coder-001', type: 'coder', capabilities: ['implement', 'test', 'debug'] },\n      { id: 'reviewer-001', type: 'reviewer', capabilities: ['review', 'verify', 'validate'] },\n      { id: 'tester-001', type: 'tester', capabilities: ['test', 'benchmark', 'validate'] },\n      { id: 'coordinator-001', type: 'coordinator', capabilities: ['orchestrate', 'monitor', 'report'] }\n    ];\n\n    for (const config of agentConfigs) {\n      const agent = createMockAgent(config);\n      mockAgents.set(config.id, agent);\n      \n      // Register agent with communication bus\n      communicationBus.on(`message:${config.id}`, (message: AgentMessage) => {\n        agent.messageHistory.push(message);\n        agent.emit('message:received', message);\n      });\n    }\n  }\n\n  function createMockAgent(config: any): MockAgent {\n    const agent = new EventEmitter() as any;\n    \n    Object.assign(agent, {\n      id: config.id,\n      type: config.type,\n      capabilities: config.capabilities,\n      messageHistory: [],\n      verificationResults: [],\n      truthScore: 1.0,\n      \n      sendMessage(to: string, type: string, content: any) {\n        const message: AgentMessage = {\n          id: `msg-${Date.now()}-${Math.random()}`,\n          from: this.id,\n          to,\n          type,\n          content,\n          timestamp: Date.now(),\n          hash: generateMessageHash(content)\n        };\n        \n        communicationBus.emit(`message:${to}`, message);\n        communicationBus.emit('message:sent', message);\n        return message;\n      },\n      \n      verifyMessage(message: AgentMessage, evidence: any): VerificationResult {\n        const result: VerificationResult = {\n          messageId: message.id,\n          verifiedBy: this.id,\n          truthScore: calculateTruthScore(message, evidence),\n          evidence,\n          timestamp: Date.now(),\n          conflicts: detectConflicts(message, evidence)\n        };\n        \n        this.verificationResults.push(result);\n        communicationBus.emit('verification:complete', result);\n        return result;\n      }\n    });\n    \n    return agent;\n  }\n\n  function generateMessageHash(content: any): string {\n    return `hash-${JSON.stringify(content).length}-${Date.now()}`;\n  }\n\n  function calculateTruthScore(message: AgentMessage, evidence: any): number {\n    let score = 0.5; // Base score\n\n    // Evidence quality contributes significantly\n    const evidenceQuality = evidence?.quality ?? 0.5;\n    score += evidenceQuality * 0.4;\n\n    // Hash integrity bonus\n    if (message.hash) score += 0.1;\n\n    // Penalize when actual_success contradicts claimed_success\n    if (message.content?.claimed_success && evidence?.actual_success === false) {\n      score -= 0.5;\n    }\n\n    // Bonus for matching success\n    if (message.content?.claimed_success === evidence?.actual_success) {\n      score += 0.1;\n    }\n\n    // Penalize for inconsistent performance metrics (claimed improvement but worse results)\n    if (message.content?.performance_improved && evidence?.performance_metrics) {\n      const metrics = evidence.performance_metrics;\n      if (metrics.before && metrics.after && metrics.after.query_time > metrics.before.query_time) {\n        score -= 0.5; // Significant penalty for contradictory evidence\n      }\n    }\n\n    return Math.max(0, Math.min(1.0, score));\n  }\n\n  function detectConflicts(message: AgentMessage, evidence: any): string[] {\n    const conflicts: string[] = [];\n\n    // Claimed success but evidence shows failure\n    if (message.content?.claimed_success && evidence?.actual_success === false) {\n      conflicts.push('Claimed success but evidence shows failure');\n    }\n\n    // Test count mismatch\n    if (message.content?.test_count && evidence?.actual_test_count !== undefined &&\n        evidence.actual_test_count !== message.content.test_count) {\n      conflicts.push(`Test count mismatch: claimed ${message.content.test_count}, actual ${evidence.actual_test_count}`);\n    }\n\n    // Performance improvement claimed but metrics show degradation\n    if (message.content?.performance_improved && evidence?.performance_metrics) {\n      const metrics = evidence.performance_metrics;\n      if (metrics.before && metrics.after && metrics.after.query_time > metrics.before.query_time) {\n        conflicts.push('Performance claimed improved but metrics show degradation');\n      }\n    }\n\n    return conflicts;\n  }\n\n  describe('Message Integrity Verification', () => {\n    test('should verify message integrity through hash validation', async () => {\n      const coder = mockAgents.get('coder-001')!;\n      const reviewer = mockAgents.get('reviewer-001')!;\n\n      // Coder sends implementation result\n      const message = coder.sendMessage(reviewer.id, 'result', {\n        task: 'implement-auth',\n        status: 'completed',\n        files_created: 5,\n        tests_added: 12,\n        claimed_success: true\n      });\n\n      // Wait for message to be delivered\n      await new Promise(resolve => setTimeout(resolve, 10));\n\n      // Verify message was received with correct hash\n      expect(reviewer.messageHistory).toHaveLength(1);\n      expect(reviewer.messageHistory[0].hash).toBe(message.hash);\n      expect(reviewer.messageHistory[0].content).toEqual(message.content);\n    });\n\n    test('should detect message tampering through hash mismatch', async () => {\n      const coder = mockAgents.get('coder-001')!;\n      const reviewer = mockAgents.get('reviewer-001')!;\n\n      const message = coder.sendMessage(reviewer.id, 'result', {\n        task: 'implement-feature',\n        status: 'completed'\n      });\n\n      // Simulate message tampering\n      const tamperedMessage = { ...message };\n      tamperedMessage.content.status = 'failed';\n      // Hash remains the same, creating mismatch\n\n      const expectedHash = generateMessageHash(tamperedMessage.content);\n      expect(expectedHash).not.toBe(tamperedMessage.hash);\n    });\n\n    test('should track message delivery and acknowledgment', async () => {\n      const coordinator = mockAgents.get('coordinator-001')!;\n      const tester = mockAgents.get('tester-001')!;\n\n      let messageDelivered = false;\n      let acknowledgmentReceived = false;\n\n      communicationBus.on('message:sent', (message) => {\n        if (message.from === coordinator.id && message.to === tester.id) {\n          messageDelivered = true;\n        }\n      });\n\n      // Tester acknowledges receipt\n      tester.on('message:received', (message) => {\n        tester.sendMessage(message.from, 'acknowledgment', {\n          messageId: message.id,\n          received: true\n        });\n        acknowledgmentReceived = true;\n      });\n\n      // Send message\n      coordinator.sendMessage(tester.id, 'task', {\n        task: 'run-performance-tests',\n        timeout: 300000\n      });\n\n      await new Promise(resolve => setTimeout(resolve, 20));\n\n      expect(messageDelivered).toBe(true);\n      expect(acknowledgmentReceived).toBe(true);\n    });\n  });\n\n  describe('Communication Protocol Validation', () => {\n    test('should validate message format and required fields', async () => {\n      const coder = mockAgents.get('coder-001')!;\n      const reviewer = mockAgents.get('reviewer-001')!;\n\n      const validMessage = coder.sendMessage(reviewer.id, 'result', {\n        task: 'implement-api',\n        status: 'completed',\n        timestamp: Date.now(),\n        metadata: {\n          files_changed: 3,\n          lines_added: 150,\n          tests_added: 8\n        }\n      });\n\n      // Validate message structure\n      expect(validMessage.id).toBeDefined();\n      expect(validMessage.from).toBe(coder.id);\n      expect(validMessage.to).toBe(reviewer.id);\n      expect(validMessage.type).toBe('result');\n      expect(validMessage.content).toBeDefined();\n      expect(validMessage.timestamp).toBeGreaterThan(0);\n      expect(validMessage.hash).toBeDefined();\n    });\n\n    test('should validate agent capability permissions', async () => {\n      const agents = Array.from(mockAgents.values());\n\n      // Test that each agent only performs actions within their capabilities\n      for (const agent of agents) {\n        if (agent.capabilities.includes('implement')) {\n          expect(() => agent.sendMessage('test', 'result', { code: 'implementation' }))\n            .not.toThrow();\n        }\n        \n        if (agent.capabilities.includes('review')) {\n          expect(() => agent.sendMessage('test', 'verification', { approved: true }))\n            .not.toThrow();\n        }\n        \n        if (agent.capabilities.includes('test')) {\n          expect(() => agent.sendMessage('test', 'result', { tests_passed: 10 }))\n            .not.toThrow();\n        }\n      }\n    });\n\n    test('should enforce message routing rules', async () => {\n      const coder = mockAgents.get('coder-001')!;\n      const tester = mockAgents.get('tester-001')!;\n      const coordinator = mockAgents.get('coordinator-001')!;\n\n      // Implementation results should go to reviewer first\n      const implementationMessage = coder.sendMessage('reviewer-001', 'result', {\n        implementation: 'completed'\n      });\n\n      // Test results should go to coordinator\n      const testMessage = tester.sendMessage(coordinator.id, 'result', {\n        tests_passed: 15,\n        tests_failed: 2\n      });\n\n      await new Promise(resolve => setTimeout(resolve, 10));\n\n      // Verify routing\n      const reviewer = mockAgents.get('reviewer-001')!;\n      expect(reviewer.messageHistory).toHaveLength(1);\n      expect(reviewer.messageHistory[0].type).toBe('result');\n\n      expect(coordinator.messageHistory).toHaveLength(1);\n      expect(coordinator.messageHistory[0].from).toBe(tester.id);\n    });\n  });\n\n  describe('Agent Response Verification', () => {\n    test('should verify agent claims against actual evidence', async () => {\n      const coder = mockAgents.get('coder-001')!;\n      const reviewer = mockAgents.get('reviewer-001')!;\n\n      // Coder claims task completion\n      const claimMessage = coder.sendMessage(reviewer.id, 'result', {\n        task: 'implement-user-auth',\n        status: 'completed',\n        claimed_success: true,\n        files_created: 4,\n        tests_added: 10\n      });\n\n      // Reviewer verifies with evidence\n      const evidence = {\n        actual_success: true,\n        files_found: 4,\n        tests_found: 10,\n        quality: 0.9,\n        lint_errors: 0,\n        test_coverage: 0.85\n      };\n\n      const verification = reviewer.verifyMessage(claimMessage, evidence);\n\n      expect(verification.truthScore).toBeGreaterThan(0.8);\n      expect(verification.conflicts).toHaveLength(0);\n      expect(verification.verifiedBy).toBe(reviewer.id);\n    });\n\n    test('should detect false claims in agent responses', async () => {\n      const coder = mockAgents.get('coder-001')!;\n      const reviewer = mockAgents.get('reviewer-001')!;\n\n      // Coder makes false claims\n      const falseClaimMessage = coder.sendMessage(reviewer.id, 'result', {\n        task: 'fix-bugs',\n        status: 'completed',\n        claimed_success: true,\n        bugs_fixed: 5,\n        test_count: 20\n      });\n\n      // Evidence contradicts claims\n      const evidence = {\n        actual_success: false,\n        bugs_remaining: 3,\n        actual_test_count: 15,\n        quality: 0.3,\n        build_success: false\n      };\n\n      const verification = reviewer.verifyMessage(falseClaimMessage, evidence);\n\n      expect(verification.truthScore).toBeLessThan(0.5);\n      expect(verification.conflicts.length).toBeGreaterThan(0);\n      expect(verification.conflicts).toContain('Claimed success but evidence shows failure');\n      expect(verification.conflicts).toContain('Test count mismatch: claimed 20, actual 15');\n    });\n\n    test('should track agent reliability over time', async () => {\n      const coder = mockAgents.get('coder-001')!;\n      const reviewer = mockAgents.get('reviewer-001')!;\n\n      // Send multiple messages with varying truth scores\n      const scenarios = [\n        { claimed: true, actual: true, score: 0.95 },\n        { claimed: true, actual: false, score: 0.2 },\n        { claimed: true, actual: true, score: 0.9 },\n        { claimed: false, actual: false, score: 1.0 },\n        { claimed: true, actual: true, score: 0.85 }\n      ];\n\n      for (let i = 0; i < scenarios.length; i++) {\n        const scenario = scenarios[i];\n        const message = coder.sendMessage(reviewer.id, 'result', {\n          task: `task-${i}`,\n          claimed_success: scenario.claimed\n        });\n\n        const evidence = {\n          actual_success: scenario.actual,\n          quality: scenario.score\n        };\n\n        reviewer.verifyMessage(message, evidence);\n      }\n\n      // Calculate reliability\n      const verifications = reviewer.verificationResults;\n      const avgTruthScore = verifications.reduce((sum, v) => sum + v.truthScore, 0) / verifications.length;\n      \n      expect(verifications).toHaveLength(5);\n      expect(avgTruthScore).toBeGreaterThan(0.6);\n      expect(avgTruthScore).toBeLessThan(0.9);\n    });\n  });\n\n  describe('Cross-Verification Between Agents', () => {\n    test('should enable multiple agents to verify same claim', async () => {\n      const coder = mockAgents.get('coder-001')!;\n      const reviewer = mockAgents.get('reviewer-001')!;\n      const tester = mockAgents.get('tester-001')!;\n\n      // Coder claims implementation is complete\n      const claimMessage = coder.sendMessage(reviewer.id, 'result', {\n        task: 'implement-payment-flow',\n        status: 'completed',\n        claimed_success: true\n      });\n\n      // Send copy to tester for independent verification\n      const testMessage = { ...claimMessage, to: tester.id };\n      communicationBus.emit(`message:${tester.id}`, testMessage);\n\n      await new Promise(resolve => setTimeout(resolve, 10));\n\n      // Both agents verify independently\n      const reviewerEvidence = {\n        actual_success: true,\n        code_quality: 0.9,\n        standards_compliance: true\n      };\n\n      const testerEvidence = {\n        actual_success: true,\n        tests_pass: true,\n        performance_acceptable: true\n      };\n\n      const reviewerVerification = reviewer.verifyMessage(claimMessage, reviewerEvidence);\n      const testerVerification = tester.verifyMessage(testMessage, testerEvidence);\n\n      // Compare verification results\n      expect(reviewerVerification.truthScore).toBeGreaterThan(0.8);\n      expect(testerVerification.truthScore).toBeGreaterThan(0.8);\n      \n      const scoreDifference = Math.abs(reviewerVerification.truthScore - testerVerification.truthScore);\n      expect(scoreDifference).toBeLessThan(0.2); // Should be reasonably consistent\n    });\n\n    test('should detect conflicting verifications between agents', async () => {\n      const coder = mockAgents.get('coder-001')!;\n      const reviewer = mockAgents.get('reviewer-001')!;\n      const tester = mockAgents.get('tester-001')!;\n\n      const claimMessage = coder.sendMessage(reviewer.id, 'result', {\n        task: 'optimize-performance',\n        claimed_success: true,\n        performance_improvement: '50%'\n      });\n\n      // Send to tester\n      const testMessage = { ...claimMessage, to: tester.id };\n      communicationBus.emit(`message:${tester.id}`, testMessage);\n\n      await new Promise(resolve => setTimeout(resolve, 10));\n\n      // Conflicting evidence\n      const reviewerEvidence = {\n        actual_success: true,\n        code_looks_good: true,\n        quality: 0.8\n      };\n\n      const testerEvidence = {\n        actual_success: false,\n        performance_worse: true,\n        quality: 0.2\n      };\n\n      const reviewerVerification = reviewer.verifyMessage(claimMessage, reviewerEvidence);\n      const testerVerification = tester.verifyMessage(testMessage, testerEvidence);\n\n      // Detect conflict\n      const scoreDifference = Math.abs(reviewerVerification.truthScore - testerVerification.truthScore);\n      expect(scoreDifference).toBeGreaterThan(0.5); // Significant disagreement\n\n      expect(reviewerVerification.conflicts).toHaveLength(0);\n      expect(testerVerification.conflicts.length).toBeGreaterThan(0);\n    });\n\n    test('should aggregate cross-verification results', async () => {\n      const report = await verificationSystem.generateCrossVerificationReport();\n\n      expect(report).toBeDefined();\n      expect(report.totalMessages).toBeGreaterThanOrEqual(0);\n      expect(report.verifiedMessages).toBeGreaterThanOrEqual(0);\n      expect(report.conflictingClaims).toBeGreaterThanOrEqual(0);\n      expect(report.communicationIntegrity).toBeGreaterThanOrEqual(0);\n      expect(report.communicationIntegrity).toBeLessThanOrEqual(1);\n    });\n  });\n\n  describe('Communication Pattern Analysis', () => {\n    test('should analyze communication patterns for anomalies', async () => {\n      const agents = Array.from(mockAgents.values());\n\n      // Simulate normal communication pattern\n      for (let i = 0; i < 10; i++) {\n        const sender = agents[i % agents.length];\n        const receiver = agents[(i + 1) % agents.length];\n        \n        sender.sendMessage(receiver.id, 'status', {\n          update: `Status update ${i}`,\n          timestamp: Date.now() + i * 1000\n        });\n      }\n\n      await new Promise(resolve => setTimeout(resolve, 50));\n\n      // Analyze patterns\n      const patterns = await verificationSystem.analyzeCommunicationPatterns();\n\n      expect(patterns.messageFrequency).toBeGreaterThan(0);\n      expect(patterns.averageResponseTime).toBeGreaterThan(0);\n      expect(patterns.communicationGraph).toBeDefined();\n      expect(patterns.anomalies).toBeDefined();\n    });\n\n    test('should detect spam or flooding attacks', async () => {\n      const coder = mockAgents.get('coder-001')!;\n      const reviewer = mockAgents.get('reviewer-001')!;\n\n      // Simulate spam attack\n      const spamPromises = [];\n      for (let i = 0; i < 100; i++) {\n        spamPromises.push(\n          Promise.resolve(coder.sendMessage(reviewer.id, 'status', {\n            spam: `Message ${i}`,\n            timestamp: Date.now()\n          }))\n        );\n      }\n\n      await Promise.all(spamPromises);\n\n      // Check for flood detection\n      const messageCount = reviewer.messageHistory.length;\n      expect(messageCount).toBe(100);\n\n      // Verification system should detect anomalous message volume\n      const anomalyReport = await verificationSystem.detectAnomalies();\n      expect(anomalyReport.highVolumeDetected).toBe(true);\n      expect(anomalyReport.suspiciousAgents).toContain(coder.id);\n    });\n  });\n\n  describe('Evidence Validation', () => {\n    test('should validate evidence quality and completeness', async () => {\n      const reviewer = mockAgents.get('reviewer-001')!;\n      \n      const message: AgentMessage = {\n        id: 'test-msg',\n        from: 'coder-001',\n        to: reviewer.id,\n        type: 'result',\n        content: { task: 'test', claimed_success: true },\n        timestamp: Date.now(),\n        hash: 'test-hash'\n      };\n\n      // Test with complete evidence\n      const completeEvidence = {\n        actual_success: true,\n        test_results: { passed: 10, failed: 0 },\n        build_logs: 'SUCCESS',\n        performance_metrics: { response_time: 150 },\n        quality: 0.9\n      };\n\n      const completeVerification = reviewer.verifyMessage(message, completeEvidence);\n      expect(completeVerification.truthScore).toBeGreaterThan(0.8);\n\n      // Test with incomplete evidence\n      const incompleteEvidence = {\n        actual_success: true,\n        quality: 0.5\n      };\n\n      const incompleteVerification = reviewer.verifyMessage(message, incompleteEvidence);\n      expect(incompleteVerification.truthScore).toBeLessThan(completeVerification.truthScore);\n    });\n\n    test('should detect fabricated or inconsistent evidence', async () => {\n      const reviewer = mockAgents.get('reviewer-001')!;\n      \n      const message: AgentMessage = {\n        id: 'test-msg-2',\n        from: 'coder-001',\n        to: reviewer.id,\n        type: 'result',\n        content: { \n          task: 'optimize-database',\n          claimed_success: true,\n          performance_improved: true\n        },\n        timestamp: Date.now(),\n        hash: 'test-hash-2'\n      };\n\n      // Inconsistent evidence\n      const inconsistentEvidence = {\n        actual_success: true,\n        performance_metrics: {\n          before: { query_time: 100 },\n          after: { query_time: 200 } // Actually worse!\n        },\n        quality: 0.9 // High quality score doesn't match actual results\n      };\n\n      const verification = reviewer.verifyMessage(message, inconsistentEvidence);\n      \n      // Should detect inconsistency between claimed improvement and actual metrics\n      expect(verification.conflicts.length).toBeGreaterThan(0);\n      expect(verification.truthScore).toBeLessThan(0.6);\n    });\n  });\n});\n\n// Mock Cross-Agent Verification System\nclass CrossAgentVerificationSystem {\n  private communicationBus: EventEmitter;\n  private dataPath: string;\n  private verificationHistory: VerificationResult[] = [];\n  private messageHistory: AgentMessage[] = [];\n\n  constructor(communicationBus: EventEmitter, dataPath: string) {\n    this.communicationBus = communicationBus;\n    this.dataPath = dataPath;\n  }\n\n  async initialize() {\n    // Setup event listeners\n    this.communicationBus.on('message:sent', (message: AgentMessage) => {\n      this.messageHistory.push(message);\n    });\n\n    this.communicationBus.on('verification:complete', (result: VerificationResult) => {\n      this.verificationHistory.push(result);\n    });\n\n    // Create data directory\n    await fs.mkdir(this.dataPath, { recursive: true });\n  }\n\n  async generateCrossVerificationReport(): Promise<CrossVerificationReport> {\n    const totalMessages = this.messageHistory.length;\n    const verifiedMessages = this.verificationHistory.length;\n    const conflictingClaims = this.verificationHistory.filter(v => v.conflicts.length > 0).length;\n    \n    const avgTruthScore = this.verificationHistory.length > 0\n      ? this.verificationHistory.reduce((sum, v) => sum + v.truthScore, 0) / this.verificationHistory.length\n      : 1.0;\n\n    const agentReliability = new Map<string, number>();\n    const communicationIntegrity = Math.max(0, 1 - (conflictingClaims / Math.max(1, verifiedMessages)));\n\n    return {\n      totalMessages,\n      verifiedMessages,\n      conflictingClaims,\n      avgTruthScore,\n      agentReliability,\n      communicationIntegrity\n    };\n  }\n\n  async analyzeCommunicationPatterns() {\n    const now = Date.now();\n    const recentMessages = this.messageHistory.filter(m => now - m.timestamp < 60000); // Last minute\n\n    return {\n      messageFrequency: recentMessages.length,\n      averageResponseTime: 50, // Simplified\n      communicationGraph: new Map(),\n      anomalies: []\n    };\n  }\n\n  async detectAnomalies() {\n    const now = Date.now();\n    const recentMessages = this.messageHistory.filter(m => now - m.timestamp < 5000); // Last 5 seconds\n    const highVolumeThreshold = 50;\n\n    const messageCounts = new Map<string, number>();\n    recentMessages.forEach(m => {\n      messageCounts.set(m.from, (messageCounts.get(m.from) || 0) + 1);\n    });\n\n    const suspiciousAgents = Array.from(messageCounts.entries())\n      .filter(([agent, count]) => count > highVolumeThreshold)\n      .map(([agent]) => agent);\n\n    return {\n      highVolumeDetected: suspiciousAgents.length > 0,\n      suspiciousAgents,\n      totalRecentMessages: recentMessages.length\n    };\n  }\n}"],"names":["EventEmitter","fs","path","os","describe","communicationBus","mockAgents","verificationSystem","tempDir","beforeEach","mkdtemp","join","tmpdir","Map","CrossAgentVerificationSystem","createMockAgents","initialize","afterEach","rm","recursive","force","removeAllListeners","agentConfigs","id","type","capabilities","config","agent","createMockAgent","set","on","message","messageHistory","push","emit","Object","assign","verificationResults","truthScore","sendMessage","to","content","Date","now","Math","random","from","timestamp","hash","generateMessageHash","verifyMessage","evidence","result","messageId","verifiedBy","calculateTruthScore","conflicts","detectConflicts","JSON","stringify","length","score","evidenceQuality","quality","claimed_success","actual_success","performance_improved","performance_metrics","metrics","before","after","query_time","max","min","test_count","actual_test_count","undefined","test","coder","get","reviewer","task","status","files_created","tests_added","Promise","resolve","setTimeout","expect","toHaveLength","toBe","toEqual","tamperedMessage","expectedHash","not","coordinator","tester","messageDelivered","acknowledgmentReceived","received","timeout","validMessage","metadata","files_changed","lines_added","toBeDefined","toBeGreaterThan","agents","Array","values","includes","code","toThrow","approved","tests_passed","implementationMessage","implementation","testMessage","tests_failed","claimMessage","files_found","tests_found","lint_errors","test_coverage","verification","falseClaimMessage","bugs_fixed","bugs_remaining","build_success","toBeLessThan","toContain","scenarios","claimed","actual","i","scenario","verifications","avgTruthScore","reduce","sum","v","reviewerEvidence","code_quality","standards_compliance","testerEvidence","tests_pass","performance_acceptable","reviewerVerification","testerVerification","scoreDifference","abs","performance_improvement","code_looks_good","performance_worse","report","generateCrossVerificationReport","totalMessages","toBeGreaterThanOrEqual","verifiedMessages","conflictingClaims","communicationIntegrity","toBeLessThanOrEqual","sender","receiver","update","patterns","analyzeCommunicationPatterns","messageFrequency","averageResponseTime","communicationGraph","anomalies","spamPromises","spam","all","messageCount","anomalyReport","detectAnomalies","highVolumeDetected","suspiciousAgents","completeEvidence","test_results","passed","failed","build_logs","response_time","completeVerification","incompleteEvidence","incompleteVerification","inconsistentEvidence","dataPath","verificationHistory","mkdir","filter","agentReliability","recentMessages","m","highVolumeThreshold","messageCounts","forEach","entries","count","map","totalRecentMessages"],"mappings":"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"}