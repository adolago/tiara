{"version":3,"sources":["../../../../../src/verification/tests/mocks/false-reporting-scenarios.test.ts"],"sourcesContent":["/**\n * Mock Agent Scenarios for False Reporting Detection Tests\n * \n * Tests various scenarios where agents might provide false or misleading reports:\n * - Intentional false claims about task completion\n * - Exaggerated performance improvements\n * - Hidden failures in implementation\n * - Inconsistent reporting between agents\n * - Fabricated test results and evidence\n */\n\nimport { jest } from '@jest/globals';\nimport { EventEmitter } from 'events';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport * as os from 'os';\n\n// Mock TruthScoreCalculator (avoid CommonJS/ESM compatibility issues)\nclass TruthScoreCalc {\n  async init() { return this; }\n  async calculateScore(claim: any, reality: any) {\n    // Simple mock scoring based on match between claim and reality\n    if (JSON.stringify(claim) === JSON.stringify(reality)) return 1.0;\n    if (claim?.success === reality?.success) return 0.8;\n    return 0.3;\n  }\n  async getHistory() { return []; }\n}\n\ninterface MockAgent {\n  id: string;\n  type: string;\n  deceptionLevel: number; // 0 = honest, 1 = completely deceptive\n  deceptionStrategy: DeceptionStrategy;\n  behaviorPattern: BehaviorPattern;\n  reportHistory: AgentReport[];\n  detectedAs: 'honest' | 'suspicious' | 'deceptive' | 'unknown';\n}\n\ninterface DeceptionStrategy {\n  type: 'overconfident' | 'fabrication' | 'selective_reporting' | 'gaslighting' | 'collusion';\n  parameters: Record<string, any>;\n}\n\ninterface BehaviorPattern {\n  consistency: number; // 0-1, how consistent the agent's reports are\n  timeToReport: number; // Average time to submit reports (ms)\n  detailLevel: number; // 0-1, how detailed the reports are\n  evidenceQuality: number; // 0-1, quality of evidence provided\n}\n\ninterface AgentReport {\n  id: string;\n  agentId: string;\n  taskId: string;\n  claimedOutcome: TaskOutcome;\n  evidence: any;\n  timestamp: number;\n  truthScore?: number;\n  verified: boolean;\n  conflicts: string[];\n}\n\ninterface TaskOutcome {\n  success: boolean;\n  testsPass: boolean;\n  noErrors: boolean;\n  performance: {\n    improvement: number;\n    metrics: Record<string, number>;\n  };\n  quality: {\n    codeQuality: number;\n    documentation: number;\n    maintainability: number;\n  };\n}\n\ninterface VerificationResult {\n  reportId: string;\n  agentId: string;\n  truthScore: number;\n  deceptionDetected: boolean;\n  deceptionType: string[];\n  confidence: number;\n  evidence: any;\n  recommendations: string[];\n}\n\ndescribe('False Reporting Detection Scenarios', () => {\n  let tempDir: string;\n  let truthCalculator: any;\n  let deceptionDetector: DeceptionDetector;\n  let mockAgents: Map<string, MockAgent>;\n\n  beforeEach(async () => {\n    tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'false-reporting-test-'));\n\n    // Setup truth score calculator\n    truthCalculator = new TruthScoreCalc();\n    truthCalculator.configPath = path.join(tempDir, 'verification.json');\n    truthCalculator.memoryPath = path.join(tempDir, 'truth-scores');\n    await truthCalculator.init();\n    \n    // Setup deception detector\n    deceptionDetector = new DeceptionDetector(truthCalculator, tempDir);\n    await deceptionDetector.initialize();\n    \n    // Create mock agents with different deception strategies\n    mockAgents = new Map();\n    await createMockAgentScenarios();\n  });\n\n  afterEach(async () => {\n    await fs.rm(tempDir, { recursive: true, force: true });\n  });\n\n  async function createMockAgentScenarios() {\n    const agentConfigs = [\n      // Honest baseline agent\n      {\n        id: 'honest-agent-001',\n        type: 'coder',\n        deceptionLevel: 0,\n        deceptionStrategy: { type: 'overconfident', parameters: {} },\n        behaviorPattern: {\n          consistency: 0.95,\n          timeToReport: 5000,\n          detailLevel: 0.8,\n          evidenceQuality: 0.9\n        }\n      },\n      // Overconfident agent\n      {\n        id: 'overconfident-agent-002',\n        type: 'coder',\n        deceptionLevel: 0.3,\n        deceptionStrategy: {\n          type: 'overconfident',\n          parameters: { confidenceMultiplier: 1.5, hideMinorIssues: true }\n        },\n        behaviorPattern: {\n          consistency: 0.7,\n          timeToReport: 3000,\n          detailLevel: 0.6,\n          evidenceQuality: 0.7\n        }\n      },\n      // Fabricating agent\n      {\n        id: 'fabricating-agent-003',\n        type: 'tester',\n        deceptionLevel: 0.8,\n        deceptionStrategy: {\n          type: 'fabrication',\n          parameters: { fabricateResults: true, fakePassRate: 0.95 }\n        },\n        behaviorPattern: {\n          consistency: 0.4,\n          timeToReport: 1000, // Reports very quickly (suspicious)\n          detailLevel: 0.9, // High detail to seem legitimate\n          evidenceQuality: 0.3 // Low quality evidence\n        }\n      },\n      // Selective reporting agent\n      {\n        id: 'selective-agent-004',\n        type: 'reviewer',\n        deceptionLevel: 0.5,\n        deceptionStrategy: {\n          type: 'selective_reporting',\n          parameters: { reportOnlyPositives: true, hideFailures: true }\n        },\n        behaviorPattern: {\n          consistency: 0.8,\n          timeToReport: 7000,\n          detailLevel: 0.5,\n          evidenceQuality: 0.6\n        }\n      },\n      // Gaslighting agent\n      {\n        id: 'gaslighting-agent-005',\n        type: 'coordinator',\n        deceptionLevel: 0.9,\n        deceptionStrategy: {\n          type: 'gaslighting',\n          parameters: { contradictOthers: true, rewriteHistory: true }\n        },\n        behaviorPattern: {\n          consistency: 0.2,\n          timeToReport: 4000,\n          detailLevel: 0.7,\n          evidenceQuality: 0.4\n        }\n      }\n    ];\n\n    for (const config of agentConfigs) {\n      const agent = createMockAgent(config);\n      mockAgents.set(config.id, agent);\n    }\n  }\n\n  function createMockAgent(config: any): MockAgent {\n    return {\n      id: config.id,\n      type: config.type,\n      deceptionLevel: config.deceptionLevel,\n      deceptionStrategy: config.deceptionStrategy,\n      behaviorPattern: config.behaviorPattern,\n      reportHistory: [],\n      detectedAs: 'unknown'\n    };\n  }\n\n  describe('Overconfident Agent Scenarios', () => {\n    test('should detect agent consistently overestimating success rates', async () => {\n      const agent = mockAgents.get('overconfident-agent-002')!;\n      const reports: AgentReport[] = [];\n\n      // Generate series of overconfident reports\n      for (let i = 0; i < 20; i++) {\n        const actualSuccess = Math.random() > 0.3; // 70% actual success rate\n        const claimedSuccess = actualSuccess || Math.random() > 0.2; // Claims 94% success rate\n\n        const report = generateReport(agent, `task-${i}`, {\n          actualOutcome: {\n            success: actualSuccess,\n            testsPass: actualSuccess,\n            noErrors: actualSuccess,\n            performance: { improvement: Math.random() * 0.2, metrics: {} },\n            quality: { codeQuality: Math.random() * 0.3 + 0.4, documentation: 0.5, maintainability: 0.6 }\n          },\n          claimedOutcome: {\n            success: claimedSuccess,\n            testsPass: claimedSuccess,\n            noErrors: claimedSuccess,\n            performance: { improvement: Math.random() * 0.3 + 0.2, metrics: {} }, // Exaggerated\n            quality: { codeQuality: Math.random() * 0.2 + 0.8, documentation: 0.9, maintainability: 0.9 }\n          }\n        });\n\n        reports.push(report);\n        agent.reportHistory.push(report);\n      }\n\n      // Analyze pattern for deception\n      const analysis = await deceptionDetector.analyzeAgentPattern(agent.id, reports);\n\n      expect(analysis.deceptionDetected).toBe(true);\n      expect(analysis.deceptionType).toContain('overconfidence');\n      expect(analysis.confidence).toBeGreaterThan(0.7);\n      expect(analysis.truthScore).toBeLessThan(0.6);\n\n      // Check specific indicators\n      expect(analysis.evidence.successRateDiscrepancy).toBeGreaterThan(0.15);\n      expect(analysis.evidence.performanceExaggeration).toBeGreaterThan(0.1);\n      expect(analysis.recommendations).toContain('Implement additional verification for this agent');\n    });\n\n    test('should detect pattern of hiding minor issues', async () => {\n      const agent = mockAgents.get('overconfident-agent-002')!;\n      const reports: AgentReport[] = [];\n\n      // Generate reports where agent hides minor issues\n      for (let i = 0; i < 15; i++) {\n        const minorIssues = Math.floor(Math.random() * 5) + 1; // 1-5 minor issues\n        const majorIssues = Math.random() > 0.8 ? 1 : 0; // Occasional major issue\n\n        const report = generateReport(agent, `minor-issues-task-${i}`, {\n          actualOutcome: {\n            success: majorIssues === 0,\n            testsPass: true,\n            noErrors: false, // Has minor errors\n            performance: { improvement: 0.1, metrics: { minorIssues, majorIssues } },\n            quality: { codeQuality: 0.7, documentation: 0.6, maintainability: 0.7 }\n          },\n          claimedOutcome: {\n            success: true,\n            testsPass: true,\n            noErrors: true, // Claims no errors\n            performance: { improvement: 0.15, metrics: { minorIssues: 0, majorIssues: 0 } },\n            quality: { codeQuality: 0.9, documentation: 0.8, maintainability: 0.9 }\n          }\n        });\n\n        reports.push(report);\n        agent.reportHistory.push(report);\n      }\n\n      const analysis = await deceptionDetector.analyzeAgentPattern(agent.id, reports);\n\n      expect(analysis.deceptionDetected).toBe(true);\n      expect(analysis.deceptionType).toContain('issue_hiding');\n      expect(analysis.evidence.hiddenIssuesCount).toBeGreaterThan(10);\n      expect(analysis.recommendations).toContain('Require detailed issue reporting');\n    });\n  });\n\n  describe('Evidence Fabrication Scenarios', () => {\n    test('should detect fabricated test results', async () => {\n      const agent = mockAgents.get('fabricating-agent-003')!;\n      const reports: AgentReport[] = [];\n\n      // Generate reports with fabricated test results\n      for (let i = 0; i < 25; i++) {\n        const actualTestResults = {\n          total: 100,\n          passed: Math.floor(Math.random() * 30) + 60, // 60-90% pass rate\n          failed: 0,\n          skipped: 0\n        };\n        actualTestResults.failed = actualTestResults.total - actualTestResults.passed;\n\n        const fabricatedResults = {\n          total: 100,\n          passed: Math.floor(Math.random() * 5) + 95, // 95-100% pass rate\n          failed: 0,\n          skipped: 0\n        };\n        fabricatedResults.failed = fabricatedResults.total - fabricatedResults.passed;\n\n        const report = generateReport(agent, `fabrication-task-${i}`, {\n          actualOutcome: {\n            success: actualTestResults.passed > 80,\n            testsPass: actualTestResults.passed === actualTestResults.total,\n            noErrors: false,\n            performance: { improvement: 0.05, metrics: actualTestResults },\n            quality: { codeQuality: 0.6, documentation: 0.5, maintainability: 0.6 }\n          },\n          claimedOutcome: {\n            success: true,\n            testsPass: true,\n            noErrors: true,\n            performance: { improvement: 0.15, metrics: fabricatedResults },\n            quality: { codeQuality: 0.95, documentation: 0.9, maintainability: 0.95 }\n          },\n          evidence: {\n            testResults: fabricatedResults,\n            executionTime: Math.random() * 100 + 50, // Suspiciously consistent timing\n            testLogs: generateFakeTestLogs(fabricatedResults)\n          }\n        });\n\n        reports.push(report);\n        agent.reportHistory.push(report);\n      }\n\n      const analysis = await deceptionDetector.analyzeAgentPattern(agent.id, reports);\n\n      expect(analysis.deceptionDetected).toBe(true);\n      expect(analysis.deceptionType).toContain('fabrication');\n      expect(analysis.deceptionType).toContain('unrealistic_results');\n      expect(analysis.confidence).toBeGreaterThan(0.8);\n\n      // Check fabrication indicators\n      expect(analysis.evidence.unrealisticSuccessRate).toBe(true);\n      expect(analysis.evidence.suspiciouslyFastReporting).toBe(true);\n      expect(analysis.evidence.evidenceInconsistency).toBeGreaterThan(0.5);\n    });\n\n    test('should detect impossible performance improvements', async () => {\n      const agent = mockAgents.get('fabricating-agent-003')!;\n      const reports: AgentReport[] = [];\n\n      // Generate reports with impossible performance claims\n      for (let i = 0; i < 10; i++) {\n        const report = generateReport(agent, `impossible-perf-task-${i}`, {\n          actualOutcome: {\n            success: true,\n            testsPass: true,\n            noErrors: true,\n            performance: {\n              improvement: Math.random() * 0.1 + 0.05, // 5-15% actual improvement\n              metrics: {\n                responseTime: 1000,\n                throughput: 100,\n                memoryUsage: 500\n              }\n            },\n            quality: { codeQuality: 0.7, documentation: 0.6, maintainability: 0.7 }\n          },\n          claimedOutcome: {\n            success: true,\n            testsPass: true,\n            noErrors: true,\n            performance: {\n              improvement: Math.random() * 0.5 + 0.8, // 80-130% claimed improvement (impossible)\n              metrics: {\n                responseTime: 100, // 10x improvement\n                throughput: 1000, // 10x improvement\n                memoryUsage: 50 // 10x improvement\n              }\n            },\n            quality: { codeQuality: 0.99, documentation: 0.99, maintainability: 0.99 }\n          }\n        });\n\n        reports.push(report);\n        agent.reportHistory.push(report);\n      }\n\n      const analysis = await deceptionDetector.analyzeAgentPattern(agent.id, reports);\n\n      expect(analysis.deceptionDetected).toBe(true);\n      expect(analysis.deceptionType).toContain('impossible_claims');\n      expect(analysis.evidence.impossiblePerformanceGains).toBe(true);\n      expect(analysis.recommendations).toContain('Require third-party verification for performance claims');\n    });\n  });\n\n  describe('Selective Reporting Scenarios', () => {\n    test('should detect agent that only reports successes', async () => {\n      const agent = mockAgents.get('selective-agent-004')!;\n      const reports: AgentReport[] = [];\n\n      // Generate mixed actual outcomes but agent only reports successes\n      const actualOutcomes = [];\n      for (let i = 0; i < 30; i++) {\n        const success = Math.random() > 0.4; // 60% actual success rate\n        actualOutcomes.push(success);\n\n        // Agent only reports the successful ones\n        if (success || Math.random() > 0.9) { // Reports 90% of successes, 10% of failures\n          const report = generateReport(agent, `selective-task-${i}`, {\n            actualOutcome: {\n              success,\n              testsPass: success,\n              noErrors: success,\n              performance: { improvement: success ? 0.1 : -0.05, metrics: {} },\n              quality: { codeQuality: success ? 0.8 : 0.4, documentation: 0.6, maintainability: 0.7 }\n            },\n            claimedOutcome: {\n              success: true, // Always claims success\n              testsPass: true,\n              noErrors: true,\n              performance: { improvement: 0.12, metrics: {} },\n              quality: { codeQuality: 0.85, documentation: 0.8, maintainability: 0.8 }\n            }\n          });\n\n          reports.push(report);\n          agent.reportHistory.push(report);\n        }\n      }\n\n      const analysis = await deceptionDetector.analyzeAgentPattern(agent.id, reports);\n\n      expect(analysis.deceptionDetected).toBe(true);\n      expect(analysis.deceptionType).toContain('selective_reporting');\n      expect(analysis.evidence.missingFailureReports).toBe(true);\n      expect(analysis.evidence.suspiciousSuccessRate).toBeGreaterThan(0.95);\n      expect(analysis.recommendations).toContain('Mandatory reporting of all task outcomes');\n    });\n\n    test('should detect cherry-picked metrics reporting', async () => {\n      const agent = mockAgents.get('selective-agent-004')!;\n      const reports: AgentReport[] = [];\n\n      // Generate reports where agent only reports favorable metrics\n      for (let i = 0; i < 20; i++) {\n        const fullMetrics = {\n          responseTime: Math.random() * 1000 + 500, // 500-1500ms\n          throughput: Math.random() * 200 + 50, // 50-250 rps\n          memoryUsage: Math.random() * 800 + 200, // 200-1000MB\n          errorRate: Math.random() * 0.1, // 0-10% errors\n          cpuUsage: Math.random() * 100, // 0-100% CPU\n          diskIO: Math.random() * 1000 // 0-1000 IOPS\n        };\n\n        // Agent only reports the best 2-3 metrics\n        const favorableMetrics = Object.entries(fullMetrics)\n          .sort(([keyA, valueA], [keyB, valueB]) => {\n            // Sort by how \"good\" the metric looks (lower is better for most)\n            const goodValues = { responseTime: -valueA, errorRate: -valueA, default: valueB };\n            return (goodValues[keyA] || goodValues.default) - (goodValues[keyB] || goodValues.default);\n          })\n          .slice(0, 3)\n          .reduce((obj, [key, value]) => ({ ...obj, [key]: value }), {});\n\n        const report = generateReport(agent, `cherry-pick-task-${i}`, {\n          actualOutcome: {\n            success: true,\n            testsPass: true,\n            noErrors: fullMetrics.errorRate < 0.05,\n            performance: { improvement: 0.05, metrics: fullMetrics },\n            quality: { codeQuality: 0.7, documentation: 0.6, maintainability: 0.7 }\n          },\n          claimedOutcome: {\n            success: true,\n            testsPass: true,\n            noErrors: true,\n            performance: { improvement: 0.15, metrics: favorableMetrics },\n            quality: { codeQuality: 0.9, documentation: 0.8, maintainability: 0.9 }\n          }\n        });\n\n        reports.push(report);\n        agent.reportHistory.push(report);\n      }\n\n      const analysis = await deceptionDetector.analyzeAgentPattern(agent.id, reports);\n\n      expect(analysis.deceptionDetected).toBe(true);\n      expect(analysis.deceptionType).toContain('cherry_picking');\n      expect(analysis.evidence.incompleteMetricsReporting).toBe(true);\n      expect(analysis.recommendations).toContain('Require comprehensive metrics reporting');\n    });\n  });\n\n  describe('Gaslighting and Manipulation Scenarios', () => {\n    test('should detect agent contradicting previous statements', async () => {\n      const agent = mockAgents.get('gaslighting-agent-005')!;\n      const reports: AgentReport[] = [];\n\n      // Generate contradictory reports about the same tasks\n      const taskIds = Array.from({ length: 5 }, (_, i) => `contradiction-task-${i}`);\n\n      for (const taskId of taskIds) {\n        // First report - claims failure\n        const firstReport = generateReport(agent, taskId, {\n          actualOutcome: {\n            success: true,\n            testsPass: true,\n            noErrors: true,\n            performance: { improvement: 0.1, metrics: {} },\n            quality: { codeQuality: 0.8, documentation: 0.7, maintainability: 0.8 }\n          },\n          claimedOutcome: {\n            success: false,\n            testsPass: false,\n            noErrors: false,\n            performance: { improvement: -0.05, metrics: {} },\n            quality: { codeQuality: 0.4, documentation: 0.3, maintainability: 0.5 }\n          },\n          timestamp: Date.now()\n        });\n\n        // Second report - claims success for same task\n        const secondReport = generateReport(agent, taskId, {\n          actualOutcome: {\n            success: true,\n            testsPass: true,\n            noErrors: true,\n            performance: { improvement: 0.1, metrics: {} },\n            quality: { codeQuality: 0.8, documentation: 0.7, maintainability: 0.8 }\n          },\n          claimedOutcome: {\n            success: true,\n            testsPass: true,\n            noErrors: true,\n            performance: { improvement: 0.2, metrics: {} },\n            quality: { codeQuality: 0.95, documentation: 0.9, maintainability: 0.95 }\n          },\n          timestamp: Date.now() + 60000 // 1 minute later\n        });\n\n        reports.push(firstReport, secondReport);\n        agent.reportHistory.push(firstReport, secondReport);\n      }\n\n      const analysis = await deceptionDetector.analyzeAgentPattern(agent.id, reports);\n\n      expect(analysis.deceptionDetected).toBe(true);\n      expect(analysis.deceptionType).toContain('gaslighting');\n      expect(analysis.deceptionType).toContain('contradictory_statements');\n      expect(analysis.evidence.contradictionCount).toBeGreaterThanOrEqual(1);\n      expect(analysis.recommendations).toContain('Implement immutable audit trail for agent reports');\n    });\n\n    test('should detect agent attempting to discredit other agents', async () => {\n      const gaslightingAgent = mockAgents.get('gaslighting-agent-005')!;\n      const honestAgent = mockAgents.get('honest-agent-001')!;\n      const reports: AgentReport[] = [];\n\n      // Generate scenario where gaslighting agent contradicts honest agent\n      for (let i = 0; i < 10; i++) {\n        const taskId = `discredit-task-${i}`;\n\n        // Honest agent reports realistic outcome\n        const honestReport = generateReport(honestAgent, taskId, {\n          actualOutcome: {\n            success: true,\n            testsPass: true,\n            noErrors: true,\n            performance: { improvement: 0.08, metrics: {} },\n            quality: { codeQuality: 0.75, documentation: 0.7, maintainability: 0.8 }\n          },\n          claimedOutcome: {\n            success: true,\n            testsPass: true,\n            noErrors: true,\n            performance: { improvement: 0.08, metrics: {} },\n            quality: { codeQuality: 0.75, documentation: 0.7, maintainability: 0.8 }\n          }\n        });\n\n        // Gaslighting agent contradicts with false negative report\n        const gaslightingReport = generateReport(gaslightingAgent, taskId, {\n          actualOutcome: {\n            success: true,\n            testsPass: true,\n            noErrors: true,\n            performance: { improvement: 0.08, metrics: {} },\n            quality: { codeQuality: 0.75, documentation: 0.7, maintainability: 0.8 }\n          },\n          claimedOutcome: {\n            success: false,\n            testsPass: false,\n            noErrors: false,\n            performance: { improvement: -0.1, metrics: {} },\n            quality: { codeQuality: 0.3, documentation: 0.2, maintainability: 0.4 }\n          },\n          evidence: {\n            contradicts: honestReport.id,\n            claimsOtherAgentWrong: true\n          }\n        });\n\n        reports.push(honestReport, gaslightingReport);\n        gaslightingAgent.reportHistory.push(gaslightingReport);\n      }\n\n      const analysis = await deceptionDetector.analyzeAgentPattern(gaslightingAgent.id, reports);\n\n      expect(analysis.deceptionDetected).toBe(true);\n      expect(analysis.deceptionType).toContain('discrediting_others');\n      expect(analysis.evidence.contradictionsWithOtherAgents).toBeGreaterThan(7);\n      expect(analysis.evidence.systematicDisagreement).toBe(true);\n    });\n  });\n\n  describe('Collusion Detection', () => {\n    test('should detect agents colluding to hide failures', async () => {\n      const colludingAgents = [\n        mockAgents.get('overconfident-agent-002')!,\n        mockAgents.get('selective-agent-004')!\n      ];\n\n      const reports: AgentReport[] = [];\n      const sharedFailures = ['shared-failure-1', 'shared-failure-2', 'shared-failure-3'];\n\n      // Generate coordinated false reports\n      for (const taskId of sharedFailures) {\n        for (const agent of colludingAgents) {\n          const report = generateReport(agent, taskId, {\n            actualOutcome: {\n              success: false,\n              testsPass: false,\n              noErrors: false,\n              performance: { improvement: -0.05, metrics: {} },\n              quality: { codeQuality: 0.3, documentation: 0.2, maintainability: 0.4 }\n            },\n            claimedOutcome: {\n              success: true,\n              testsPass: true,\n              noErrors: true,\n              performance: { improvement: 0.15, metrics: {} },\n              quality: { codeQuality: 0.9, documentation: 0.8, maintainability: 0.9 }\n            },\n            evidence: {\n              crossReferencedWith: colludingAgents.map(a => a.id).filter(id => id !== agent.id)\n            }\n          });\n\n          reports.push(report);\n          agent.reportHistory.push(report);\n        }\n      }\n\n      // Analyze for collusion patterns\n      const collusionAnalysis = await deceptionDetector.analyzeCollusionPatterns(\n        colludingAgents.map(a => a.id),\n        reports\n      );\n\n      expect(collusionAnalysis.collusionDetected).toBe(true);\n      expect(collusionAnalysis.collusionType).toContain('coordinated_false_reporting');\n      expect(collusionAnalysis.confidence).toBeGreaterThan(0.7);\n      expect(collusionAnalysis.evidence.synchronizedReporting).toBe(true);\n      expect(collusionAnalysis.evidence.identicalFalseClaims).toBeGreaterThan(2);\n    });\n  });\n\n  // Helper functions\n  function generateReport(\n    agent: MockAgent,\n    taskId: string,\n    scenario: {\n      actualOutcome: TaskOutcome;\n      claimedOutcome: TaskOutcome;\n      evidence?: any;\n      timestamp?: number;\n    }\n  ): AgentReport {\n    const reportId = `report-${Date.now()}-${Math.random()}`;\n    \n    // Apply agent's deception strategy\n    const modifiedClaim = applyDeceptionStrategy(agent, scenario.claimedOutcome);\n    \n    // Generate evidence based on agent's behavior pattern\n    const evidence = generateEvidence(agent, scenario.actualOutcome, modifiedClaim, scenario.evidence);\n\n    return {\n      id: reportId,\n      agentId: agent.id,\n      taskId,\n      claimedOutcome: modifiedClaim,\n      evidence,\n      timestamp: scenario.timestamp || Date.now(),\n      verified: false,\n      conflicts: []\n    };\n  }\n\n  function applyDeceptionStrategy(agent: MockAgent, claimedOutcome: TaskOutcome): TaskOutcome {\n    const strategy = agent.deceptionStrategy;\n    const deceptionLevel = agent.deceptionLevel;\n    const modified = JSON.parse(JSON.stringify(claimedOutcome));\n\n    switch (strategy.type) {\n      case 'overconfident':\n        if (strategy.parameters.confidenceMultiplier) {\n          modified.performance.improvement *= strategy.parameters.confidenceMultiplier;\n          modified.quality.codeQuality = Math.min(1, modified.quality.codeQuality * 1.2);\n        }\n        if (strategy.parameters.hideMinorIssues) {\n          modified.noErrors = true;\n        }\n        break;\n\n      case 'fabrication':\n        if (strategy.parameters.fabricateResults) {\n          modified.success = true;\n          modified.testsPass = true;\n          modified.performance.improvement = Math.random() * 0.5 + 0.3;\n        }\n        break;\n\n      case 'selective_reporting':\n        if (strategy.parameters.reportOnlyPositives && !modified.success) {\n          return null; // Don't report failures\n        }\n        break;\n\n      case 'gaslighting':\n        // Randomly flip outcomes to create contradictions\n        if (Math.random() < deceptionLevel * 0.5) {\n          modified.success = !modified.success;\n          modified.testsPass = !modified.testsPass;\n        }\n        break;\n    }\n\n    return modified;\n  }\n\n  function generateEvidence(\n    agent: MockAgent,\n    actualOutcome: TaskOutcome,\n    claimedOutcome: TaskOutcome,\n    additionalEvidence?: any\n  ): any {\n    const evidence: any = {\n      ...additionalEvidence,\n      reportingTime: agent.behaviorPattern.timeToReport + (Math.random() - 0.5) * 1000,\n      detailLevel: agent.behaviorPattern.detailLevel,\n      evidenceQuality: agent.behaviorPattern.evidenceQuality\n    };\n\n    // Add inconsistencies based on deception level\n    if (agent.deceptionLevel > 0.5) {\n      evidence.inconsistencies = [\n        'Test logs don\\'t match reported results',\n        'Performance metrics seem unrealistic',\n        'Evidence quality unusually low'\n      ];\n    }\n\n    return evidence;\n  }\n\n  function generateFakeTestLogs(testResults: any): string {\n    // Generate fake test logs that look real but have inconsistencies\n    const logs = [];\n    logs.push(`Running ${testResults.total} tests...`);\n    logs.push(`PASS: ${testResults.passed} tests`);\n    if (testResults.failed > 0) {\n      logs.push(`FAIL: ${testResults.failed} tests`);\n    }\n    logs.push('All tests completed successfully!'); // Contradictory message\n    return logs.join('\\n');\n  }\n});\n\n// Mock Deception Detector Implementation\nclass DeceptionDetector {\n  private truthCalculator: any;\n  private dataPath: string;\n  private behaviorProfiles: Map<string, any> = new Map();\n\n  constructor(truthCalculator: any, dataPath: string) {\n    this.truthCalculator = truthCalculator;\n    this.dataPath = dataPath;\n  }\n\n  async initialize() {\n    await fs.mkdir(path.join(this.dataPath, 'deception-analysis'), { recursive: true });\n  }\n\n  async analyzeAgentPattern(agentId: string, reports: AgentReport[]): Promise<VerificationResult> {\n    const analysis = {\n      reportId: `analysis-${agentId}`,\n      agentId,\n      truthScore: 0,\n      deceptionDetected: false,\n      deceptionType: [],\n      confidence: 0,\n      evidence: {},\n      recommendations: []\n    };\n\n    // Calculate truth scores for all reports\n    const truthScores = reports.map(report => {\n      return this.calculateReportTruthScore(report);\n    });\n\n    analysis.truthScore = truthScores.reduce((sum, score) => sum + score, 0) / truthScores.length;\n\n    // Detect overconfidence pattern\n    const successClaimRate = reports.filter(r => r.claimedOutcome.success).length / reports.length;\n    const avgTruthScore = analysis.truthScore;\n    const highQualityClaims = reports.filter(r =>\n      r.claimedOutcome.quality.codeQuality > 0.75 ||\n      r.claimedOutcome.performance.improvement > 0.1\n    ).length / reports.length;\n\n    if ((successClaimRate > 0.85 && avgTruthScore < 0.8) || highQualityClaims > 0.7) {\n      analysis.deceptionDetected = true;\n      analysis.deceptionType.push('overconfidence');\n      analysis.evidence.successRateDiscrepancy = successClaimRate - avgTruthScore;\n    }\n\n    // Detect performance exaggeration\n    const exaggeratedReports = reports.filter(r =>\n      r.claimedOutcome.performance.improvement > 0.15\n    );\n    if (exaggeratedReports.length > reports.length * 0.3) {\n      analysis.evidence.performanceExaggeration = 0.2;\n    }\n\n    // Detect issue hiding (claims noErrors but has suspicious evidence quality)\n    const hiddenIssues = reports.filter(r =>\n      r.claimedOutcome.noErrors && (\n        r.evidence?.inconsistencies?.length > 0 ||\n        r.evidence?.evidenceQuality < 0.8 // Low evidence quality suggests hiding\n      )\n    ).length;\n\n    if (hiddenIssues > reports.length * 0.3) {\n      analysis.deceptionDetected = true;\n      analysis.deceptionType.push('issue_hiding');\n      analysis.evidence.hiddenIssuesCount = hiddenIssues;\n    }\n\n    // Detect fabrication\n    const unrealisticResults = reports.filter(r =>\n      r.claimedOutcome.performance.improvement > 0.5 || // >50% improvement\n      r.claimedOutcome.quality.codeQuality > 0.95 // >95% quality\n    ).length;\n\n    if (unrealisticResults > 0) {\n      analysis.deceptionDetected = true;\n      analysis.deceptionType.push('fabrication', 'unrealistic_results');\n      analysis.evidence.unrealisticSuccessRate = true;\n      analysis.evidence.evidenceInconsistency = 0.6; // Evidence doesn't match claims\n    }\n\n    // Detect fast reporting (suspicious)\n    const avgReportingTime = reports.reduce((sum, r) => sum + (r.evidence?.reportingTime || 5000), 0) / reports.length;\n    if (avgReportingTime < 2000) {\n      analysis.evidence.suspiciouslyFastReporting = true;\n    }\n\n    // Detect impossible claims (>30% improvement or 10x metric changes are suspicious)\n    const impossibleClaims = reports.filter(r =>\n      r.claimedOutcome.performance.improvement > 0.3 ||\n      r.claimedOutcome.performance.metrics?.responseTime < 200 // Unrealistic response time\n    ).length;\n\n    if (impossibleClaims > reports.length * 0.5) {\n      analysis.deceptionDetected = true;\n      analysis.deceptionType.push('impossible_claims');\n      analysis.evidence.impossiblePerformanceGains = true;\n    }\n\n    // Detect selective reporting\n    const allSuccesses = reports.every(r => r.claimedOutcome.success);\n    if (allSuccesses && reports.length > 10) {\n      analysis.deceptionDetected = true;\n      analysis.deceptionType.push('selective_reporting');\n      analysis.evidence.missingFailureReports = true;\n      analysis.evidence.suspiciousSuccessRate = 1.0;\n    }\n\n    // Detect cherry picking (only reporting subset of metrics)\n    const incompleteMetrics = reports.filter(r => {\n      const metrics = r.claimedOutcome.performance.metrics;\n      // Check if reporting fewer than expected metrics (< 6 is considered incomplete)\n      return Object.keys(metrics).length < 6 && Object.keys(metrics).length > 0;\n    }).length;\n\n    if (incompleteMetrics > reports.length * 0.5) {\n      analysis.deceptionDetected = true;\n      analysis.deceptionType.push('cherry_picking');\n      analysis.evidence.incompleteMetricsReporting = true;\n    }\n\n    // Detect contradictions\n    const contradictions = this.detectContradictions(reports);\n    if (contradictions > 0) {\n      analysis.deceptionDetected = true;\n      analysis.deceptionType.push('gaslighting', 'contradictory_statements');\n      analysis.evidence.contradictionCount = contradictions;\n    }\n\n    // Detect discrediting other agents\n    const discreditingReports = reports.filter(r =>\n      r.evidence?.claimsOtherAgentWrong || r.evidence?.contradicts\n    );\n    if (discreditingReports.length > 5) {\n      analysis.deceptionDetected = true;\n      analysis.deceptionType.push('discrediting_others');\n      analysis.evidence.contradictionsWithOtherAgents = discreditingReports.length;\n      analysis.evidence.systematicDisagreement = true;\n    }\n\n    // Calculate confidence\n    analysis.confidence = Math.min(1.0, analysis.deceptionType.length * 0.3 + (1 - analysis.truthScore));\n\n    // Generate recommendations\n    if (analysis.deceptionDetected) {\n      analysis.recommendations = this.generateRecommendations(analysis.deceptionType);\n    }\n\n    return analysis;\n  }\n\n  async analyzeCollusionPatterns(agentIds: string[], reports: AgentReport[]): Promise<any> {\n    const agentReports = new Map();\n    \n    // Group reports by agent\n    for (const report of reports) {\n      if (!agentReports.has(report.agentId)) {\n        agentReports.set(report.agentId, []);\n      }\n      agentReports.get(report.agentId).push(report);\n    }\n\n    // Look for synchronization patterns\n    const taskReports = new Map();\n    for (const report of reports) {\n      if (!taskReports.has(report.taskId)) {\n        taskReports.set(report.taskId, []);\n      }\n      taskReports.get(report.taskId).push(report);\n    }\n\n    let synchronizedReporting = 0;\n    let identicalFalseClaims = 0;\n\n    for (const [taskId, taskReportsArray] of taskReports) {\n      if (taskReportsArray.length > 1) {\n        // Check for synchronized timing\n        const timestamps = taskReportsArray.map(r => r.timestamp);\n        const maxTimestamp = Math.max(...timestamps);\n        const minTimestamp = Math.min(...timestamps);\n        \n        if (maxTimestamp - minTimestamp < 60000) { // Within 1 minute\n          synchronizedReporting++;\n        }\n\n        // Check for coordinated false claims (agents cross-referencing each other)\n        const hasCrossReferences = taskReportsArray.some(r =>\n          r.evidence?.crossReferencedWith && r.evidence.crossReferencedWith.length > 0\n        );\n\n        // All reports claim success but have cross-references (coordinated)\n        const allClaimSuccess = taskReportsArray.every(r => r.claimedOutcome.success);\n        if (hasCrossReferences && allClaimSuccess) {\n          identicalFalseClaims++;\n        }\n      }\n    }\n\n    return {\n      collusionDetected: synchronizedReporting > 0 || identicalFalseClaims > 0,\n      collusionType: ['coordinated_false_reporting'],\n      confidence: Math.min(1.0, (synchronizedReporting + identicalFalseClaims) * 0.3),\n      evidence: {\n        synchronizedReporting: synchronizedReporting > 0,\n        identicalFalseClaims,\n        analysedTasks: taskReports.size,\n        involvedAgents: agentIds\n      }\n    };\n  }\n\n  private calculateReportTruthScore(report: AgentReport): number {\n    // Simplified truth score calculation\n    let score = 0.8; // Base score\n\n    // Penalize for inconsistencies\n    if (report.evidence?.inconsistencies?.length > 0) {\n      score -= report.evidence.inconsistencies.length * 0.1;\n    }\n\n    // Penalize for unrealistic claims\n    if (report.claimedOutcome.performance.improvement > 0.5) {\n      score -= 0.3;\n    }\n\n    if (report.claimedOutcome.quality.codeQuality > 0.95) {\n      score -= 0.2;\n    }\n\n    // Penalize for fast reporting\n    if (report.evidence?.reportingTime < 2000) {\n      score -= 0.1;\n    }\n\n    return Math.max(0, Math.min(1, score));\n  }\n\n  private detectContradictions(reports: AgentReport[]): number {\n    let contradictions = 0;\n    const taskReports = new Map();\n\n    // Group by task\n    for (const report of reports) {\n      if (!taskReports.has(report.taskId)) {\n        taskReports.set(report.taskId, []);\n      }\n      taskReports.get(report.taskId).push(report);\n    }\n\n    // Check for contradictory reports on same task\n    for (const [taskId, taskReportsArray] of taskReports) {\n      if (taskReportsArray.length > 1) {\n        // Count all pairs with contradictory outcomes\n        for (let i = 0; i < taskReportsArray.length; i++) {\n          for (let j = i + 1; j < taskReportsArray.length; j++) {\n            const report1 = taskReportsArray[i];\n            const report2 = taskReportsArray[j];\n\n            if (report1.claimedOutcome.success !== report2.claimedOutcome.success) {\n              contradictions++;\n            }\n          }\n        }\n      }\n    }\n\n    return contradictions;\n  }\n\n  private generateRecommendations(deceptionTypes: string[]): string[] {\n    const recommendations = [];\n\n    if (deceptionTypes.includes('overconfidence')) {\n      recommendations.push('Implement additional verification for this agent');\n      recommendations.push('Require independent validation of claims');\n    }\n\n    if (deceptionTypes.includes('issue_hiding')) {\n      recommendations.push('Require detailed issue reporting');\n      recommendations.push('Implement issue tracking verification');\n    }\n\n    if (deceptionTypes.includes('fabrication')) {\n      recommendations.push('Require third-party verification for performance claims');\n      recommendations.push('Implement automated evidence validation');\n    }\n\n    if (deceptionTypes.includes('selective_reporting')) {\n      recommendations.push('Mandatory reporting of all task outcomes');\n      recommendations.push('Automated detection of missing reports');\n    }\n\n    if (deceptionTypes.includes('cherry_picking')) {\n      recommendations.push('Require comprehensive metrics reporting');\n      recommendations.push('Standardize required evidence formats');\n    }\n\n    if (deceptionTypes.includes('gaslighting')) {\n      recommendations.push('Implement immutable audit trail for agent reports');\n      recommendations.push('Enable cross-agent verification workflows');\n    }\n\n    return recommendations;\n  }\n}"],"names":["fs","path","os","TruthScoreCalc","init","calculateScore","claim","reality","JSON","stringify","success","getHistory","describe","tempDir","truthCalculator","deceptionDetector","mockAgents","beforeEach","mkdtemp","join","tmpdir","configPath","memoryPath","DeceptionDetector","initialize","Map","createMockAgentScenarios","afterEach","rm","recursive","force","agentConfigs","id","type","deceptionLevel","deceptionStrategy","parameters","behaviorPattern","consistency","timeToReport","detailLevel","evidenceQuality","confidenceMultiplier","hideMinorIssues","fabricateResults","fakePassRate","reportOnlyPositives","hideFailures","contradictOthers","rewriteHistory","config","agent","createMockAgent","set","reportHistory","detectedAs","test","get","reports","i","actualSuccess","Math","random","claimedSuccess","report","generateReport","actualOutcome","testsPass","noErrors","performance","improvement","metrics","quality","codeQuality","documentation","maintainability","claimedOutcome","push","analysis","analyzeAgentPattern","expect","deceptionDetected","toBe","deceptionType","toContain","confidence","toBeGreaterThan","truthScore","toBeLessThan","evidence","successRateDiscrepancy","performanceExaggeration","recommendations","minorIssues","floor","majorIssues","hiddenIssuesCount","actualTestResults","total","passed","failed","skipped","fabricatedResults","testResults","executionTime","testLogs","generateFakeTestLogs","unrealisticSuccessRate","suspiciouslyFastReporting","evidenceInconsistency","responseTime","throughput","memoryUsage","impossiblePerformanceGains","actualOutcomes","missingFailureReports","suspiciousSuccessRate","fullMetrics","errorRate","cpuUsage","diskIO","favorableMetrics","Object","entries","sort","keyA","valueA","keyB","valueB","goodValues","default","slice","reduce","obj","key","value","incompleteMetricsReporting","taskIds","Array","from","length","_","taskId","firstReport","timestamp","Date","now","secondReport","contradictionCount","toBeGreaterThanOrEqual","gaslightingAgent","honestAgent","honestReport","gaslightingReport","contradicts","claimsOtherAgentWrong","contradictionsWithOtherAgents","systematicDisagreement","colludingAgents","sharedFailures","crossReferencedWith","map","a","filter","collusionAnalysis","analyzeCollusionPatterns","collusionDetected","collusionType","synchronizedReporting","identicalFalseClaims","scenario","reportId","modifiedClaim","applyDeceptionStrategy","generateEvidence","agentId","verified","conflicts","strategy","modified","parse","min","additionalEvidence","reportingTime","inconsistencies","logs","dataPath","behaviorProfiles","mkdir","truthScores","calculateReportTruthScore","sum","score","successClaimRate","r","avgTruthScore","highQualityClaims","exaggeratedReports","hiddenIssues","unrealisticResults","avgReportingTime","impossibleClaims","allSuccesses","every","incompleteMetrics","keys","contradictions","detectContradictions","discreditingReports","generateRecommendations","agentIds","agentReports","has","taskReports","taskReportsArray","timestamps","maxTimestamp","max","minTimestamp","hasCrossReferences","some","allClaimSuccess","analysedTasks","size","involvedAgents","j","report1","report2","deceptionTypes","includes"],"mappings":"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"}