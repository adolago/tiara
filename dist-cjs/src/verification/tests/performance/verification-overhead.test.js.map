{"version":3,"sources":["../../../../../src/verification/tests/performance/verification-overhead.test.ts"],"sourcesContent":["/**\n * Performance Benchmark Tests for Verification Overhead\n * \n * Tests the performance impact of the verification system including:\n * - Truth scoring calculation performance\n * - Memory usage during verification\n * - Throughput under load\n * - Latency impact on agent communication\n */\n\nimport { jest } from '@jest/globals';\nimport { performance } from 'perf_hooks';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport * as os from 'os';\n\n// Mock TruthScoreCalculator (avoid CommonJS/ESM compatibility issues)\nclass TruthScoreCalculator {\n  configPath: string = '';\n  memoryPath: string = '';\n  private storage: Map<string, any[]> = new Map();\n\n  async init() {\n    await fs.mkdir(this.memoryPath, { recursive: true }).catch(() => {});\n    return this;\n  }\n\n  clearStorage() {\n    this.storage.clear();\n  }\n\n  // Synchronous for performance testing (avoids Promise overhead in benchmarks)\n  calculateScore(evidence: any): number {\n    // Simulate some computation\n    const testsPassed = evidence?.test_results?.passed ?? 0;\n    const testsTotal = evidence?.test_results?.total ?? 1;\n    const lintErrors = evidence?.lint_results?.errors ?? 0;\n    const buildSuccess = evidence?.build_results?.success ?? true;\n\n    let score = testsPassed / testsTotal;\n    score -= lintErrors * 0.05;\n    if (!buildSuccess) score -= 0.3;\n\n    return Math.max(0, Math.min(1.0, score));\n  }\n\n  compareClaimToReality(claim: any, reality: any): { truth_score: number; matches: boolean } {\n    const claimStr = JSON.stringify(claim);\n    const realityStr = JSON.stringify(reality);\n    const matches = claimStr === realityStr;\n    const truth_score = matches ? 1.0 : (claim?.tests_pass === reality?.tests_pass ? 0.7 : 0.3);\n    return { truth_score, matches };\n  }\n\n  async storeTruthScore(agentId: string, taskId: string, score: number, evidence: any): Promise<void> {\n    const entry = { agentId, taskId, score, evidence, timestamp: Date.now() };\n\n    // Store in memory for retrieval\n    const agentEntries = this.storage.get(agentId) || [];\n    agentEntries.push(entry);\n    this.storage.set(agentId, agentEntries);\n\n    // Also write to file\n    const filePath = path.join(this.memoryPath, `${agentId}-${taskId}.json`);\n    await fs.writeFile(filePath, JSON.stringify(entry, null, 2));\n  }\n\n  async getAgentHistory(agentId: string, limit: number): Promise<any[]> {\n    const entries = this.storage.get(agentId) || [];\n    return entries.slice(-limit);\n  }\n\n  async generateReport(format: 'json' | 'markdown'): Promise<any> {\n    const allEntries: any[] = [];\n    const agentStats: Record<string, { count: number; avgScore: number }> = {};\n\n    for (const [agentId, entries] of this.storage) {\n      allEntries.push(...entries);\n      const avgScore = entries.reduce((s, e) => s + e.score, 0) / entries.length;\n      agentStats[agentId] = { count: entries.length, avgScore };\n    }\n\n    if (format === 'json') {\n      return {\n        total_verifications: allEntries.length,\n        agents: agentStats,\n        average_score: allEntries.length ? allEntries.reduce((s, e) => s + e.score, 0) / allEntries.length : 0\n      };\n    } else {\n      return `# Truth Score Report\\n\\n## Agent Performance\\n\\n${\n        Object.entries(agentStats).map(([id, stats]) =>\n          `- ${id}: ${stats.count} verifications, avg score ${stats.avgScore.toFixed(2)}`\n        ).join('\\n')\n      }`;\n    }\n  }\n\n  async getHistory() { return []; }\n  async saveScore(_score: any) { }\n}\n\ninterface PerformanceMetrics {\n  operations: number;\n  totalTime: number;\n  averageTime: number;\n  throughput: number;\n  memoryUsage: {\n    initial: number;\n    peak: number;\n    final: number;\n    delta: number;\n  };\n  p50: number;\n  p95: number;\n  p99: number;\n}\n\ninterface BenchmarkResult {\n  testName: string;\n  metrics: PerformanceMetrics;\n  passed: boolean;\n  thresholds: BenchmarkThresholds;\n}\n\ninterface BenchmarkThresholds {\n  maxAverageTime: number;\n  minThroughput: number;\n  maxMemoryDelta: number;\n  maxP99Latency: number;\n}\n\ndescribe('Verification System Performance Benchmarks', () => {\n  let tempDir: string;\n  let calculator: any;\n  let performanceResults: BenchmarkResult[] = [];\n\n  beforeAll(async () => {\n    tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'verification-perf-'));\n    \n    // Setup truth score calculator\n    calculator = new TruthScoreCalculator();\n    calculator.configPath = path.join(tempDir, 'verification.json');\n    calculator.memoryPath = path.join(tempDir, 'truth-scores');\n    await calculator.init();\n  });\n\n  afterAll(async () => {\n    await fs.rm(tempDir, { recursive: true, force: true });\n    \n    // Generate performance report\n    await generatePerformanceReport(performanceResults);\n  });\n\n  describe('Truth Score Calculation Performance', () => {\n    test('should calculate truth scores efficiently at scale', async () => {\n      const thresholds: BenchmarkThresholds = {\n        maxAverageTime: 5, // 5ms per calculation\n        minThroughput: 200, // 200 calculations per second\n        maxMemoryDelta: 50 * 1024 * 1024, // 50MB max memory increase\n        maxP99Latency: 20 // 20ms p99 latency\n      };\n\n      const operations = 1000;\n      const evidenceVariants = generateEvidenceVariants(10);\n      const durations: number[] = [];\n      \n      const initialMemory = process.memoryUsage().heapUsed;\n      let peakMemory = initialMemory;\n\n      const startTime = performance.now();\n\n      for (let i = 0; i < operations; i++) {\n        const evidence = evidenceVariants[i % evidenceVariants.length];\n        \n        const operationStart = performance.now();\n        const score = calculator.calculateScore(evidence);\n        const operationEnd = performance.now();\n        \n        durations.push(operationEnd - operationStart);\n        \n        // Track memory usage\n        const currentMemory = process.memoryUsage().heapUsed;\n        peakMemory = Math.max(peakMemory, currentMemory);\n        \n        // Verify score is valid\n        expect(score).toBeGreaterThanOrEqual(0);\n        expect(score).toBeLessThanOrEqual(1);\n      }\n\n      const endTime = performance.now();\n      const finalMemory = process.memoryUsage().heapUsed;\n      \n      const metrics = calculatePerformanceMetrics(operations, durations, startTime, endTime, {\n        initial: initialMemory,\n        peak: peakMemory,\n        final: finalMemory\n      });\n\n      const result: BenchmarkResult = {\n        testName: 'Truth Score Calculation Performance',\n        metrics,\n        passed: validateBenchmark(metrics, thresholds),\n        thresholds\n      };\n\n      performanceResults.push(result);\n\n      // Assert performance requirements\n      expect(metrics.averageTime).toBeLessThanOrEqual(thresholds.maxAverageTime);\n      expect(metrics.throughput).toBeGreaterThanOrEqual(thresholds.minThroughput);\n      expect(metrics.memoryUsage.delta).toBeLessThanOrEqual(thresholds.maxMemoryDelta);\n      expect(metrics.p99).toBeLessThanOrEqual(thresholds.maxP99Latency);\n    });\n\n    test('should handle concurrent truth score calculations efficiently', async () => {\n      const thresholds: BenchmarkThresholds = {\n        maxAverageTime: 8, // 8ms per calculation (slightly higher for concurrency)\n        minThroughput: 150, // 150 calculations per second\n        maxMemoryDelta: 100 * 1024 * 1024, // 100MB max memory increase\n        maxP99Latency: 30 // 30ms p99 latency\n      };\n\n      const concurrency = 10;\n      const operationsPerWorker = 100;\n      const totalOperations = concurrency * operationsPerWorker;\n\n      const initialMemory = process.memoryUsage().heapUsed;\n      const startTime = performance.now();\n\n      // Create concurrent workers\n      const workerPromises = Array.from({ length: concurrency }, async (_, workerIndex) => {\n        const workerDurations: number[] = [];\n        const evidenceVariants = generateEvidenceVariants(5);\n\n        for (let i = 0; i < operationsPerWorker; i++) {\n          const evidence = evidenceVariants[i % evidenceVariants.length];\n          \n          const operationStart = performance.now();\n          const score = calculator.calculateScore(evidence);\n          const operationEnd = performance.now();\n          \n          workerDurations.push(operationEnd - operationStart);\n          \n          expect(score).toBeGreaterThanOrEqual(0);\n          expect(score).toBeLessThanOrEqual(1);\n\n          // Add small delay to simulate realistic workload\n          if (i % 10 === 0) {\n            await new Promise(resolve => setTimeout(resolve, 1));\n          }\n        }\n\n        return workerDurations;\n      });\n\n      const allDurations = (await Promise.all(workerPromises)).flat();\n      const endTime = performance.now();\n      const finalMemory = process.memoryUsage().heapUsed;\n\n      const metrics = calculatePerformanceMetrics(totalOperations, allDurations, startTime, endTime, {\n        initial: initialMemory,\n        peak: finalMemory, // Simplified for concurrent case\n        final: finalMemory\n      });\n\n      const result: BenchmarkResult = {\n        testName: 'Concurrent Truth Score Calculation',\n        metrics,\n        passed: validateBenchmark(metrics, thresholds),\n        thresholds\n      };\n\n      performanceResults.push(result);\n\n      expect(metrics.averageTime).toBeLessThanOrEqual(thresholds.maxAverageTime);\n      expect(metrics.throughput).toBeGreaterThanOrEqual(thresholds.minThroughput);\n      expect(metrics.memoryUsage.delta).toBeLessThanOrEqual(thresholds.maxMemoryDelta);\n    }, 30000);\n  });\n\n  describe('Memory Usage Optimization', () => {\n    test('should maintain stable memory usage during extended operations', async () => {\n      const thresholds: BenchmarkThresholds = {\n        maxAverageTime: 10, // 10ms per operation\n        minThroughput: 100, // 100 operations per second\n        maxMemoryDelta: 20 * 1024 * 1024, // 20MB max memory increase\n        maxP99Latency: 50 // 50ms p99 latency\n      };\n\n      const operations = 2000;\n      const evidenceVariants = generateEvidenceVariants(20);\n      const durations: number[] = [];\n      const memorySnapshots: number[] = [];\n\n      const initialMemory = process.memoryUsage().heapUsed;\n      memorySnapshots.push(initialMemory);\n\n      const startTime = performance.now();\n\n      for (let i = 0; i < operations; i++) {\n        const evidence = evidenceVariants[i % evidenceVariants.length];\n        \n        const operationStart = performance.now();\n        \n        // Perform multiple operations to test memory accumulation\n        const score1 = calculator.calculateScore(evidence);\n        const comparison = calculator.compareClaimToReality(\n          { tests_pass: true, no_lint_errors: true },\n          { tests_pass: score1 > 0.8, lint_errors: score1 > 0.9 ? 0 : 2 }\n        );\n        \n        const operationEnd = performance.now();\n        durations.push(operationEnd - operationStart);\n\n        // Take memory snapshots every 100 operations\n        if (i % 100 === 0) {\n          const currentMemory = process.memoryUsage().heapUsed;\n          memorySnapshots.push(currentMemory);\n\n          // Force garbage collection every 500 operations to test cleanup\n          if (i % 500 === 0 && global.gc) {\n            global.gc();\n          }\n        }\n      }\n\n      const endTime = performance.now();\n      const finalMemory = process.memoryUsage().heapUsed;\n      const peakMemory = Math.max(...memorySnapshots);\n\n      const metrics = calculatePerformanceMetrics(operations, durations, startTime, endTime, {\n        initial: initialMemory,\n        peak: peakMemory,\n        final: finalMemory\n      });\n\n      // Check for memory leaks by analyzing memory growth trend\n      const memoryGrowthRate = (finalMemory - initialMemory) / operations;\n      expect(memoryGrowthRate).toBeLessThan(1000); // Less than 1KB per operation\n\n      const result: BenchmarkResult = {\n        testName: 'Extended Memory Usage Stability',\n        metrics,\n        passed: validateBenchmark(metrics, thresholds) && memoryGrowthRate < 1000,\n        thresholds\n      };\n\n      performanceResults.push(result);\n\n      expect(metrics.memoryUsage.delta).toBeLessThanOrEqual(thresholds.maxMemoryDelta);\n    }, 45000);\n\n    test('should efficiently handle large evidence datasets', async () => {\n      const thresholds: BenchmarkThresholds = {\n        maxAverageTime: 15, // 15ms per operation (larger datasets)\n        minThroughput: 70, // 70 operations per second\n        maxMemoryDelta: 150 * 1024 * 1024, // 150MB max memory increase\n        maxP99Latency: 100 // 100ms p99 latency\n      };\n\n      const operations = 500;\n      const durations: number[] = [];\n\n      const initialMemory = process.memoryUsage().heapUsed;\n      const startTime = performance.now();\n\n      for (let i = 0; i < operations; i++) {\n        // Create large evidence objects\n        const largeEvidence = generateLargeEvidence(i);\n        \n        const operationStart = performance.now();\n        const score = calculator.calculateScore(largeEvidence);\n        const operationEnd = performance.now();\n        \n        durations.push(operationEnd - operationStart);\n        \n        expect(score).toBeGreaterThanOrEqual(0);\n        expect(score).toBeLessThanOrEqual(1);\n\n        // Cleanup large objects to prevent memory accumulation\n        if (i % 50 === 0 && global.gc) {\n          global.gc();\n        }\n      }\n\n      const endTime = performance.now();\n      const finalMemory = process.memoryUsage().heapUsed;\n\n      const metrics = calculatePerformanceMetrics(operations, durations, startTime, endTime, {\n        initial: initialMemory,\n        peak: finalMemory,\n        final: finalMemory\n      });\n\n      const result: BenchmarkResult = {\n        testName: 'Large Evidence Dataset Handling',\n        metrics,\n        passed: validateBenchmark(metrics, thresholds),\n        thresholds\n      };\n\n      performanceResults.push(result);\n\n      expect(metrics.averageTime).toBeLessThanOrEqual(thresholds.maxAverageTime);\n      expect(metrics.throughput).toBeGreaterThanOrEqual(thresholds.minThroughput);\n    }, 30000);\n  });\n\n  describe('Truth Score Storage Performance', () => {\n    test('should store truth scores efficiently at high volume', async () => {\n      const thresholds: BenchmarkThresholds = {\n        maxAverageTime: 20, // 20ms per storage operation\n        minThroughput: 50, // 50 storage operations per second\n        maxMemoryDelta: 100 * 1024 * 1024, // 100MB max memory increase\n        maxP99Latency: 100 // 100ms p99 latency\n      };\n\n      const operations = 200; // Reduced for storage operations\n      const durations: number[] = [];\n\n      const initialMemory = process.memoryUsage().heapUsed;\n      const startTime = performance.now();\n\n      for (let i = 0; i < operations; i++) {\n        const agentId = `agent-${i % 10}`;\n        const taskId = `task-${i}`;\n        const score = Math.random();\n        const evidence = generateEvidenceVariants(1)[0];\n\n        const operationStart = performance.now();\n        await calculator.storeTruthScore(agentId, taskId, score, evidence);\n        const operationEnd = performance.now();\n        \n        durations.push(operationEnd - operationStart);\n      }\n\n      const endTime = performance.now();\n      const finalMemory = process.memoryUsage().heapUsed;\n\n      const metrics = calculatePerformanceMetrics(operations, durations, startTime, endTime, {\n        initial: initialMemory,\n        peak: finalMemory,\n        final: finalMemory\n      });\n\n      const result: BenchmarkResult = {\n        testName: 'High Volume Truth Score Storage',\n        metrics,\n        passed: validateBenchmark(metrics, thresholds),\n        thresholds\n      };\n\n      performanceResults.push(result);\n\n      expect(metrics.averageTime).toBeLessThanOrEqual(thresholds.maxAverageTime);\n      expect(metrics.throughput).toBeGreaterThanOrEqual(thresholds.minThroughput);\n\n      // Verify all files were created\n      const files = await fs.readdir(calculator.memoryPath);\n      expect(files.length).toBe(operations);\n    }, 30000);\n\n    test('should retrieve agent history efficiently', async () => {\n      const thresholds: BenchmarkThresholds = {\n        maxAverageTime: 50, // 50ms per history retrieval\n        minThroughput: 20, // 20 retrievals per second\n        maxMemoryDelta: 50 * 1024 * 1024, // 50MB max memory increase\n        maxP99Latency: 200 // 200ms p99 latency\n      };\n\n      // First, create test data\n      const agents = Array.from({ length: 10 }, (_, i) => `perf-agent-${i}`);\n      for (const agentId of agents) {\n        for (let i = 0; i < 50; i++) {\n          await calculator.storeTruthScore(\n            agentId,\n            `history-task-${i}`,\n            Math.random(),\n            { test: `data-${i}` }\n          );\n        }\n      }\n\n      const operations = 100;\n      const durations: number[] = [];\n\n      const initialMemory = process.memoryUsage().heapUsed;\n      const startTime = performance.now();\n\n      for (let i = 0; i < operations; i++) {\n        const agentId = agents[i % agents.length];\n        const limit = Math.floor(Math.random() * 20) + 5; // 5-24 entries\n\n        const operationStart = performance.now();\n        const history = await calculator.getAgentHistory(agentId, limit);\n        const operationEnd = performance.now();\n        \n        durations.push(operationEnd - operationStart);\n        \n        expect(history.length).toBeLessThanOrEqual(limit);\n        expect(history.length).toBeGreaterThan(0);\n      }\n\n      const endTime = performance.now();\n      const finalMemory = process.memoryUsage().heapUsed;\n\n      const metrics = calculatePerformanceMetrics(operations, durations, startTime, endTime, {\n        initial: initialMemory,\n        peak: finalMemory,\n        final: finalMemory\n      });\n\n      const result: BenchmarkResult = {\n        testName: 'Agent History Retrieval Performance',\n        metrics,\n        passed: validateBenchmark(metrics, thresholds),\n        thresholds\n      };\n\n      performanceResults.push(result);\n\n      expect(metrics.averageTime).toBeLessThanOrEqual(thresholds.maxAverageTime);\n      expect(metrics.throughput).toBeGreaterThanOrEqual(thresholds.minThroughput);\n    }, 45000);\n  });\n\n  describe('Report Generation Performance', () => {\n    test('should generate reports efficiently with large datasets', async () => {\n      const thresholds: BenchmarkThresholds = {\n        maxAverageTime: 1000, // 1 second per report generation\n        minThroughput: 1, // 1 report per second\n        maxMemoryDelta: 200 * 1024 * 1024, // 200MB max memory increase\n        maxP99Latency: 3000 // 3 second p99 latency\n      };\n\n      // Clear storage to ensure isolated test\n      calculator.clearStorage();\n\n      // Create large dataset for report generation\n      const agents = Array.from({ length: 50 }, (_, i) => `report-agent-${i}`);\n      for (const agentId of agents) {\n        for (let i = 0; i < 100; i++) {\n          await calculator.storeTruthScore(\n            agentId,\n            `report-task-${i}`,\n            Math.random(),\n            { complexity: Math.random(), quality: Math.random() }\n          );\n        }\n      }\n\n      const operations = 10; // Fewer operations for expensive report generation\n      const durations: number[] = [];\n\n      const initialMemory = process.memoryUsage().heapUsed;\n      const startTime = performance.now();\n\n      for (let i = 0; i < operations; i++) {\n        const format = i % 2 === 0 ? 'json' : 'markdown';\n\n        const operationStart = performance.now();\n        const report = await calculator.generateReport(format);\n        const operationEnd = performance.now();\n        \n        durations.push(operationEnd - operationStart);\n        \n        if (format === 'json') {\n          expect(typeof report).toBe('object');\n          expect(report.total_verifications).toBeGreaterThan(0);\n          expect(Object.keys(report.agents).length).toBe(agents.length);\n        } else {\n          expect(typeof report).toBe('string');\n          expect(report).toContain('# Truth Score Report');\n          expect(report).toContain('Agent Performance');\n        }\n\n        // Force garbage collection between operations\n        if (global.gc) {\n          global.gc();\n        }\n      }\n\n      const endTime = performance.now();\n      const finalMemory = process.memoryUsage().heapUsed;\n\n      const metrics = calculatePerformanceMetrics(operations, durations, startTime, endTime, {\n        initial: initialMemory,\n        peak: finalMemory,\n        final: finalMemory\n      });\n\n      const result: BenchmarkResult = {\n        testName: 'Large Dataset Report Generation',\n        metrics,\n        passed: validateBenchmark(metrics, thresholds),\n        thresholds\n      };\n\n      performanceResults.push(result);\n\n      expect(metrics.averageTime).toBeLessThanOrEqual(thresholds.maxAverageTime);\n      expect(metrics.throughput).toBeGreaterThanOrEqual(thresholds.minThroughput);\n    }, 60000);\n  });\n\n  describe('System Load Testing', () => {\n    test('should maintain performance under sustained load', async () => {\n      const thresholds: BenchmarkThresholds = {\n        maxAverageTime: 25, // 25ms average under load\n        minThroughput: 40, // 40 operations per second\n        maxMemoryDelta: 300 * 1024 * 1024, // 300MB max memory increase\n        maxP99Latency: 150 // 150ms p99 latency\n      };\n\n      const loadDuration = 15000; // 15 seconds of sustained load\n      const batchSize = 10;\n      const batchInterval = 100; // 100ms between batches\n\n      const durations: number[] = [];\n      const initialMemory = process.memoryUsage().heapUsed;\n      const startTime = performance.now();\n      \n      let operationCount = 0;\n      const evidenceVariants = generateEvidenceVariants(5);\n\n      const loadTestPromise = new Promise<void>((resolve) => {\n        const interval = setInterval(async () => {\n          if (performance.now() - startTime >= loadDuration) {\n            clearInterval(interval);\n            resolve();\n            return;\n          }\n\n          // Process batch of operations\n          const batchPromises = Array.from({ length: batchSize }, async (_, i) => {\n            const evidence = evidenceVariants[(operationCount + i) % evidenceVariants.length];\n            \n            const operationStart = performance.now();\n            \n            // Mixed operations to simulate realistic load\n            if (i % 3 === 0) {\n              const score = calculator.calculateScore(evidence);\n              expect(score).toBeGreaterThanOrEqual(0);\n            } else if (i % 3 === 1) {\n              const comparison = calculator.compareClaimToReality(\n                { tests_pass: true },\n                { tests_pass: Math.random() > 0.5 }\n              );\n              expect(comparison.truth_score).toBeGreaterThanOrEqual(0);\n            } else {\n              await calculator.storeTruthScore(\n                `load-agent-${operationCount + i}`,\n                `load-task-${operationCount + i}`,\n                Math.random(),\n                evidence\n              );\n            }\n            \n            const operationEnd = performance.now();\n            durations.push(operationEnd - operationStart);\n          });\n\n          await Promise.all(batchPromises);\n          operationCount += batchSize;\n        }, batchInterval);\n      });\n\n      await loadTestPromise;\n\n      const endTime = performance.now();\n      const finalMemory = process.memoryUsage().heapUsed;\n\n      const metrics = calculatePerformanceMetrics(operationCount, durations, startTime, endTime, {\n        initial: initialMemory,\n        peak: finalMemory,\n        final: finalMemory\n      });\n\n      const result: BenchmarkResult = {\n        testName: 'Sustained Load Performance',\n        metrics,\n        passed: validateBenchmark(metrics, thresholds),\n        thresholds\n      };\n\n      performanceResults.push(result);\n\n      expect(metrics.averageTime).toBeLessThanOrEqual(thresholds.maxAverageTime);\n      expect(metrics.throughput).toBeGreaterThanOrEqual(thresholds.minThroughput);\n      expect(operationCount).toBeGreaterThan(100); // Should process significant number of operations\n    }, 20000);\n  });\n\n  // Helper functions\n  function generateEvidenceVariants(count: number): any[] {\n    return Array.from({ length: count }, (_, i) => ({\n      test_results: {\n        passed: Math.floor(Math.random() * 20),\n        total: 20\n      },\n      lint_results: {\n        errors: Math.floor(Math.random() * 5)\n      },\n      type_results: {\n        errors: Math.floor(Math.random() * 3)\n      },\n      build_results: {\n        success: Math.random() > 0.2\n      },\n      performance_metrics: {\n        response_time: Math.random() * 500 + 50,\n        memory_usage: Math.random() * 100 + 50\n      },\n      complexity_score: Math.random(),\n      variant_id: i\n    }));\n  }\n\n  function generateLargeEvidence(index: number): any {\n    return {\n      test_results: {\n        passed: Math.floor(Math.random() * 100),\n        total: 100,\n        detailed_results: Array.from({ length: 100 }, (_, i) => ({\n          test_name: `test_${i}`,\n          status: Math.random() > 0.1 ? 'passed' : 'failed',\n          duration: Math.random() * 1000,\n          memory_usage: Math.random() * 50\n        }))\n      },\n      lint_results: {\n        errors: Math.floor(Math.random() * 10),\n        warnings: Math.floor(Math.random() * 20),\n        file_reports: Array.from({ length: 50 }, (_, i) => ({\n          file: `file_${i}.js`,\n          issues: Math.floor(Math.random() * 5)\n        }))\n      },\n      build_results: {\n        success: Math.random() > 0.1,\n        build_log: 'x'.repeat(10000), // 10KB of build log data\n        dependencies: Array.from({ length: 200 }, (_, i) => `package_${i}`)\n      },\n      performance_data: {\n        metrics: Array.from({ length: 1000 }, () => Math.random() * 100),\n        timestamps: Array.from({ length: 1000 }, (_, i) => Date.now() + i * 1000)\n      },\n      index\n    };\n  }\n\n  function calculatePerformanceMetrics(\n    operations: number,\n    durations: number[],\n    startTime: number,\n    endTime: number,\n    memory: { initial: number; peak: number; final: number }\n  ): PerformanceMetrics {\n    const totalTime = endTime - startTime;\n    const averageTime = durations.length > 0\n      ? durations.reduce((a, b) => a + b, 0) / durations.length\n      : 0;\n    const throughput = totalTime > 0 ? (operations / totalTime) * 1000 : 0; // Operations per second\n\n    const sortedDurations = [...durations].sort((a, b) => a - b);\n    const getPercentile = (pct: number) => {\n      if (sortedDurations.length === 0) return 0;\n      const index = Math.min(Math.floor(sortedDurations.length * pct), sortedDurations.length - 1);\n      return sortedDurations[index] ?? 0;\n    };\n\n    return {\n      operations,\n      totalTime,\n      averageTime,\n      throughput,\n      memoryUsage: {\n        initial: memory.initial,\n        peak: memory.peak,\n        final: memory.final,\n        delta: memory.final - memory.initial\n      },\n      p50: getPercentile(0.5),\n      p95: getPercentile(0.95),\n      p99: getPercentile(0.99)\n    };\n  }\n\n  function validateBenchmark(metrics: PerformanceMetrics, thresholds: BenchmarkThresholds): boolean {\n    return (\n      metrics.averageTime <= thresholds.maxAverageTime &&\n      metrics.throughput >= thresholds.minThroughput &&\n      metrics.memoryUsage.delta <= thresholds.maxMemoryDelta &&\n      metrics.p99 <= thresholds.maxP99Latency\n    );\n  }\n\n  async function generatePerformanceReport(results: BenchmarkResult[]) {\n    if (results.length === 0) return;\n\n    try {\n      const reportPath = path.join(tempDir, 'performance-report.json');\n      const report = {\n        timestamp: new Date().toISOString(),\n        summary: {\n          totalTests: results.length,\n          passedTests: results.filter(r => r.passed).length,\n          failedTests: results.filter(r => !r.passed).length\n        },\n        results: results.map(r => ({\n          testName: r.testName,\n          passed: r.passed,\n          metrics: {\n            averageTime: `${(r.metrics.averageTime ?? 0).toFixed(2)}ms`,\n            throughput: `${(r.metrics.throughput ?? 0).toFixed(2)} ops/sec`,\n            memoryDelta: `${((r.metrics.memoryUsage?.delta ?? 0) / 1024 / 1024).toFixed(2)}MB`,\n            p99Latency: `${(r.metrics.p99 ?? 0).toFixed(2)}ms`\n          },\n          thresholds: {\n            maxAverageTime: `${r.thresholds.maxAverageTime}ms`,\n            minThroughput: `${r.thresholds.minThroughput} ops/sec`,\n            maxMemoryDelta: `${(r.thresholds.maxMemoryDelta / 1024 / 1024).toFixed(0)}MB`,\n            maxP99Latency: `${r.thresholds.maxP99Latency}ms`\n          }\n        }))\n      };\n\n      await fs.mkdir(tempDir, { recursive: true }).catch(() => {});\n      await fs.writeFile(reportPath, JSON.stringify(report, null, 2));\n      console.log(`Performance report generated: ${reportPath}`);\n    } catch (error) {\n      // Ignore errors during report generation (cleanup may have removed tempDir)\n      console.log('Performance report generation skipped due to cleanup');\n    }\n  }\n});"],"names":["performance","fs","path","os","TruthScoreCalculator","configPath","memoryPath","storage","Map","init","mkdir","recursive","catch","clearStorage","clear","calculateScore","evidence","testsPassed","test_results","passed","testsTotal","total","lintErrors","lint_results","errors","buildSuccess","build_results","success","score","Math","max","min","compareClaimToReality","claim","reality","claimStr","JSON","stringify","realityStr","matches","truth_score","tests_pass","storeTruthScore","agentId","taskId","entry","timestamp","Date","now","agentEntries","get","push","set","filePath","join","writeFile","getAgentHistory","limit","entries","slice","generateReport","format","allEntries","agentStats","avgScore","reduce","s","e","length","count","total_verifications","agents","average_score","Object","map","id","stats","toFixed","getHistory","saveScore","_score","describe","tempDir","calculator","performanceResults","beforeAll","mkdtemp","tmpdir","afterAll","rm","force","generatePerformanceReport","test","thresholds","maxAverageTime","minThroughput","maxMemoryDelta","maxP99Latency","operations","evidenceVariants","generateEvidenceVariants","durations","initialMemory","process","memoryUsage","heapUsed","peakMemory","startTime","i","operationStart","operationEnd","currentMemory","expect","toBeGreaterThanOrEqual","toBeLessThanOrEqual","endTime","finalMemory","metrics","calculatePerformanceMetrics","initial","peak","final","result","testName","validateBenchmark","averageTime","throughput","delta","p99","concurrency","operationsPerWorker","totalOperations","workerPromises","Array","from","_","workerIndex","workerDurations","Promise","resolve","setTimeout","allDurations","all","flat","memorySnapshots","score1","comparison","no_lint_errors","lint_errors","global","gc","memoryGrowthRate","toBeLessThan","largeEvidence","generateLargeEvidence","random","files","readdir","toBe","floor","history","toBeGreaterThan","complexity","quality","report","keys","toContain","loadDuration","batchSize","batchInterval","operationCount","loadTestPromise","interval","setInterval","clearInterval","batchPromises","type_results","performance_metrics","response_time","memory_usage","complexity_score","variant_id","index","detailed_results","test_name","status","duration","warnings","file_reports","file","issues","build_log","repeat","dependencies","performance_data","timestamps","memory","totalTime","a","b","sortedDurations","sort","getPercentile","pct","p50","p95","results","reportPath","toISOString","summary","totalTests","passedTests","filter","r","failedTests","memoryDelta","p99Latency","console","log","error"],"mappings":"AAWA,SAASA,WAAW,QAAQ,aAAa;AACzC,YAAYC,QAAQ,cAAc;AAClC,YAAYC,UAAU,OAAO;AAC7B,YAAYC,QAAQ,KAAK;AAGzB,IAAA,AAAMC,uBAAN,MAAMA;IACJC,aAAqB,GAAG;IACxBC,aAAqB,GAAG;IAChBC,UAA8B,IAAIC,MAAM;IAEhD,MAAMC,OAAO;QACX,MAAMR,GAAGS,KAAK,CAAC,IAAI,CAACJ,UAAU,EAAE;YAAEK,WAAW;QAAK,GAAGC,KAAK,CAAC,KAAO;QAClE,OAAO,IAAI;IACb;IAEAC,eAAe;QACb,IAAI,CAACN,OAAO,CAACO,KAAK;IACpB;IAGAC,eAAeC,QAAa,EAAU;QAEpC,MAAMC,cAAcD,UAAUE,cAAcC,UAAU;QACtD,MAAMC,aAAaJ,UAAUE,cAAcG,SAAS;QACpD,MAAMC,aAAaN,UAAUO,cAAcC,UAAU;QACrD,MAAMC,eAAeT,UAAUU,eAAeC,WAAW;QAEzD,IAAIC,QAAQX,cAAcG;QAC1BQ,SAASN,aAAa;QACtB,IAAI,CAACG,cAAcG,SAAS;QAE5B,OAAOC,KAAKC,GAAG,CAAC,GAAGD,KAAKE,GAAG,CAAC,KAAKH;IACnC;IAEAI,sBAAsBC,KAAU,EAAEC,OAAY,EAA6C;QACzF,MAAMC,WAAWC,KAAKC,SAAS,CAACJ;QAChC,MAAMK,aAAaF,KAAKC,SAAS,CAACH;QAClC,MAAMK,UAAUJ,aAAaG;QAC7B,MAAME,cAAcD,UAAU,MAAON,OAAOQ,eAAeP,SAASO,aAAa,MAAM;QACvF,OAAO;YAAED;YAAaD;QAAQ;IAChC;IAEA,MAAMG,gBAAgBC,OAAe,EAAEC,MAAc,EAAEhB,KAAa,EAAEZ,QAAa,EAAiB;QAClG,MAAM6B,QAAQ;YAAEF;YAASC;YAAQhB;YAAOZ;YAAU8B,WAAWC,KAAKC,GAAG;QAAG;QAGxE,MAAMC,eAAe,IAAI,CAAC1C,OAAO,CAAC2C,GAAG,CAACP,YAAY,EAAE;QACpDM,aAAaE,IAAI,CAACN;QAClB,IAAI,CAACtC,OAAO,CAAC6C,GAAG,CAACT,SAASM;QAG1B,MAAMI,WAAWnD,KAAKoD,IAAI,CAAC,IAAI,CAAChD,UAAU,EAAE,GAAGqC,QAAQ,CAAC,EAAEC,OAAO,KAAK,CAAC;QACvE,MAAM3C,GAAGsD,SAAS,CAACF,UAAUjB,KAAKC,SAAS,CAACQ,OAAO,MAAM;IAC3D;IAEA,MAAMW,gBAAgBb,OAAe,EAAEc,KAAa,EAAkB;QACpE,MAAMC,UAAU,IAAI,CAACnD,OAAO,CAAC2C,GAAG,CAACP,YAAY,EAAE;QAC/C,OAAOe,QAAQC,KAAK,CAAC,CAACF;IACxB;IAEA,MAAMG,eAAeC,MAA2B,EAAgB;QAC9D,MAAMC,aAAoB,EAAE;QAC5B,MAAMC,aAAkE,CAAC;QAEzE,KAAK,MAAM,CAACpB,SAASe,QAAQ,IAAI,IAAI,CAACnD,OAAO,CAAE;YAC7CuD,WAAWX,IAAI,IAAIO;YACnB,MAAMM,WAAWN,QAAQO,MAAM,CAAC,CAACC,GAAGC,IAAMD,IAAIC,EAAEvC,KAAK,EAAE,KAAK8B,QAAQU,MAAM;YAC1EL,UAAU,CAACpB,QAAQ,GAAG;gBAAE0B,OAAOX,QAAQU,MAAM;gBAAEJ;YAAS;QAC1D;QAEA,IAAIH,WAAW,QAAQ;YACrB,OAAO;gBACLS,qBAAqBR,WAAWM,MAAM;gBACtCG,QAAQR;gBACRS,eAAeV,WAAWM,MAAM,GAAGN,WAAWG,MAAM,CAAC,CAACC,GAAGC,IAAMD,IAAIC,EAAEvC,KAAK,EAAE,KAAKkC,WAAWM,MAAM,GAAG;YACvG;QACF,OAAO;YACL,OAAO,CAAC,gDAAgD,EACtDK,OAAOf,OAAO,CAACK,YAAYW,GAAG,CAAC,CAAC,CAACC,IAAIC,MAAM,GACzC,CAAC,EAAE,EAAED,GAAG,EAAE,EAAEC,MAAMP,KAAK,CAAC,0BAA0B,EAAEO,MAAMZ,QAAQ,CAACa,OAAO,CAAC,IAAI,EAC/EvB,IAAI,CAAC,OACP;QACJ;IACF;IAEA,MAAMwB,aAAa;QAAE,OAAO,EAAE;IAAE;IAChC,MAAMC,UAAUC,MAAW,EAAE,CAAE;AACjC;AAgCAC,SAAS,8CAA8C;IACrD,IAAIC;IACJ,IAAIC;IACJ,IAAIC,qBAAwC,EAAE;IAE9CC,UAAU;QACRH,UAAU,MAAMjF,GAAGqF,OAAO,CAACpF,KAAKoD,IAAI,CAACnD,GAAGoF,MAAM,IAAI;QAGlDJ,aAAa,IAAI/E;QACjB+E,WAAW9E,UAAU,GAAGH,KAAKoD,IAAI,CAAC4B,SAAS;QAC3CC,WAAW7E,UAAU,GAAGJ,KAAKoD,IAAI,CAAC4B,SAAS;QAC3C,MAAMC,WAAW1E,IAAI;IACvB;IAEA+E,SAAS;QACP,MAAMvF,GAAGwF,EAAE,CAACP,SAAS;YAAEvE,WAAW;YAAM+E,OAAO;QAAK;QAGpD,MAAMC,0BAA0BP;IAClC;IAEAH,SAAS,uCAAuC;QAC9CW,KAAK,sDAAsD;YACzD,MAAMC,aAAkC;gBACtCC,gBAAgB;gBAChBC,eAAe;gBACfC,gBAAgB,KAAK,OAAO;gBAC5BC,eAAe;YACjB;YAEA,MAAMC,aAAa;YACnB,MAAMC,mBAAmBC,yBAAyB;YAClD,MAAMC,YAAsB,EAAE;YAE9B,MAAMC,gBAAgBC,QAAQC,WAAW,GAAGC,QAAQ;YACpD,IAAIC,aAAaJ;YAEjB,MAAMK,YAAY3G,YAAYgD,GAAG;YAEjC,IAAK,IAAI4D,IAAI,GAAGA,IAAIV,YAAYU,IAAK;gBACnC,MAAM5F,WAAWmF,gBAAgB,CAACS,IAAIT,iBAAiB/B,MAAM,CAAC;gBAE9D,MAAMyC,iBAAiB7G,YAAYgD,GAAG;gBACtC,MAAMpB,QAAQuD,WAAWpE,cAAc,CAACC;gBACxC,MAAM8F,eAAe9G,YAAYgD,GAAG;gBAEpCqD,UAAUlD,IAAI,CAAC2D,eAAeD;gBAG9B,MAAME,gBAAgBR,QAAQC,WAAW,GAAGC,QAAQ;gBACpDC,aAAa7E,KAAKC,GAAG,CAAC4E,YAAYK;gBAGlCC,OAAOpF,OAAOqF,sBAAsB,CAAC;gBACrCD,OAAOpF,OAAOsF,mBAAmB,CAAC;YACpC;YAEA,MAAMC,UAAUnH,YAAYgD,GAAG;YAC/B,MAAMoE,cAAcb,QAAQC,WAAW,GAAGC,QAAQ;YAElD,MAAMY,UAAUC,4BAA4BpB,YAAYG,WAAWM,WAAWQ,SAAS;gBACrFI,SAASjB;gBACTkB,MAAMd;gBACNe,OAAOL;YACT;YAEA,MAAMM,SAA0B;gBAC9BC,UAAU;gBACVN;gBACAlG,QAAQyG,kBAAkBP,SAASxB;gBACnCA;YACF;YAEAT,mBAAmBjC,IAAI,CAACuE;YAGxBV,OAAOK,QAAQQ,WAAW,EAAEX,mBAAmB,CAACrB,WAAWC,cAAc;YACzEkB,OAAOK,QAAQS,UAAU,EAAEb,sBAAsB,CAACpB,WAAWE,aAAa;YAC1EiB,OAAOK,QAAQb,WAAW,CAACuB,KAAK,EAAEb,mBAAmB,CAACrB,WAAWG,cAAc;YAC/EgB,OAAOK,QAAQW,GAAG,EAAEd,mBAAmB,CAACrB,WAAWI,aAAa;QAClE;QAEAL,KAAK,iEAAiE;YACpE,MAAMC,aAAkC;gBACtCC,gBAAgB;gBAChBC,eAAe;gBACfC,gBAAgB,MAAM,OAAO;gBAC7BC,eAAe;YACjB;YAEA,MAAMgC,cAAc;YACpB,MAAMC,sBAAsB;YAC5B,MAAMC,kBAAkBF,cAAcC;YAEtC,MAAM5B,gBAAgBC,QAAQC,WAAW,GAAGC,QAAQ;YACpD,MAAME,YAAY3G,YAAYgD,GAAG;YAGjC,MAAMoF,iBAAiBC,MAAMC,IAAI,CAAC;gBAAElE,QAAQ6D;YAAY,GAAG,OAAOM,GAAGC;gBACnE,MAAMC,kBAA4B,EAAE;gBACpC,MAAMtC,mBAAmBC,yBAAyB;gBAElD,IAAK,IAAIQ,IAAI,GAAGA,IAAIsB,qBAAqBtB,IAAK;oBAC5C,MAAM5F,WAAWmF,gBAAgB,CAACS,IAAIT,iBAAiB/B,MAAM,CAAC;oBAE9D,MAAMyC,iBAAiB7G,YAAYgD,GAAG;oBACtC,MAAMpB,QAAQuD,WAAWpE,cAAc,CAACC;oBACxC,MAAM8F,eAAe9G,YAAYgD,GAAG;oBAEpCyF,gBAAgBtF,IAAI,CAAC2D,eAAeD;oBAEpCG,OAAOpF,OAAOqF,sBAAsB,CAAC;oBACrCD,OAAOpF,OAAOsF,mBAAmB,CAAC;oBAGlC,IAAIN,IAAI,OAAO,GAAG;wBAChB,MAAM,IAAI8B,QAAQC,CAAAA,UAAWC,WAAWD,SAAS;oBACnD;gBACF;gBAEA,OAAOF;YACT;YAEA,MAAMI,eAAe,AAAC,CAAA,MAAMH,QAAQI,GAAG,CAACV,eAAc,EAAGW,IAAI;YAC7D,MAAM5B,UAAUnH,YAAYgD,GAAG;YAC/B,MAAMoE,cAAcb,QAAQC,WAAW,GAAGC,QAAQ;YAElD,MAAMY,UAAUC,4BAA4Ba,iBAAiBU,cAAclC,WAAWQ,SAAS;gBAC7FI,SAASjB;gBACTkB,MAAMJ;gBACNK,OAAOL;YACT;YAEA,MAAMM,SAA0B;gBAC9BC,UAAU;gBACVN;gBACAlG,QAAQyG,kBAAkBP,SAASxB;gBACnCA;YACF;YAEAT,mBAAmBjC,IAAI,CAACuE;YAExBV,OAAOK,QAAQQ,WAAW,EAAEX,mBAAmB,CAACrB,WAAWC,cAAc;YACzEkB,OAAOK,QAAQS,UAAU,EAAEb,sBAAsB,CAACpB,WAAWE,aAAa;YAC1EiB,OAAOK,QAAQb,WAAW,CAACuB,KAAK,EAAEb,mBAAmB,CAACrB,WAAWG,cAAc;QACjF,GAAG;IACL;IAEAf,SAAS,6BAA6B;QACpCW,KAAK,kEAAkE;YACrE,MAAMC,aAAkC;gBACtCC,gBAAgB;gBAChBC,eAAe;gBACfC,gBAAgB,KAAK,OAAO;gBAC5BC,eAAe;YACjB;YAEA,MAAMC,aAAa;YACnB,MAAMC,mBAAmBC,yBAAyB;YAClD,MAAMC,YAAsB,EAAE;YAC9B,MAAM2C,kBAA4B,EAAE;YAEpC,MAAM1C,gBAAgBC,QAAQC,WAAW,GAAGC,QAAQ;YACpDuC,gBAAgB7F,IAAI,CAACmD;YAErB,MAAMK,YAAY3G,YAAYgD,GAAG;YAEjC,IAAK,IAAI4D,IAAI,GAAGA,IAAIV,YAAYU,IAAK;gBACnC,MAAM5F,WAAWmF,gBAAgB,CAACS,IAAIT,iBAAiB/B,MAAM,CAAC;gBAE9D,MAAMyC,iBAAiB7G,YAAYgD,GAAG;gBAGtC,MAAMiG,SAAS9D,WAAWpE,cAAc,CAACC;gBACzC,MAAMkI,aAAa/D,WAAWnD,qBAAqB,CACjD;oBAAES,YAAY;oBAAM0G,gBAAgB;gBAAK,GACzC;oBAAE1G,YAAYwG,SAAS;oBAAKG,aAAaH,SAAS,MAAM,IAAI;gBAAE;gBAGhE,MAAMnC,eAAe9G,YAAYgD,GAAG;gBACpCqD,UAAUlD,IAAI,CAAC2D,eAAeD;gBAG9B,IAAID,IAAI,QAAQ,GAAG;oBACjB,MAAMG,gBAAgBR,QAAQC,WAAW,GAAGC,QAAQ;oBACpDuC,gBAAgB7F,IAAI,CAAC4D;oBAGrB,IAAIH,IAAI,QAAQ,KAAKyC,OAAOC,EAAE,EAAE;wBAC9BD,OAAOC,EAAE;oBACX;gBACF;YACF;YAEA,MAAMnC,UAAUnH,YAAYgD,GAAG;YAC/B,MAAMoE,cAAcb,QAAQC,WAAW,GAAGC,QAAQ;YAClD,MAAMC,aAAa7E,KAAKC,GAAG,IAAIkH;YAE/B,MAAM3B,UAAUC,4BAA4BpB,YAAYG,WAAWM,WAAWQ,SAAS;gBACrFI,SAASjB;gBACTkB,MAAMd;gBACNe,OAAOL;YACT;YAGA,MAAMmC,mBAAmB,AAACnC,CAAAA,cAAcd,aAAY,IAAKJ;YACzDc,OAAOuC,kBAAkBC,YAAY,CAAC;YAEtC,MAAM9B,SAA0B;gBAC9BC,UAAU;gBACVN;gBACAlG,QAAQyG,kBAAkBP,SAASxB,eAAe0D,mBAAmB;gBACrE1D;YACF;YAEAT,mBAAmBjC,IAAI,CAACuE;YAExBV,OAAOK,QAAQb,WAAW,CAACuB,KAAK,EAAEb,mBAAmB,CAACrB,WAAWG,cAAc;QACjF,GAAG;QAEHJ,KAAK,qDAAqD;YACxD,MAAMC,aAAkC;gBACtCC,gBAAgB;gBAChBC,eAAe;gBACfC,gBAAgB,MAAM,OAAO;gBAC7BC,eAAe;YACjB;YAEA,MAAMC,aAAa;YACnB,MAAMG,YAAsB,EAAE;YAE9B,MAAMC,gBAAgBC,QAAQC,WAAW,GAAGC,QAAQ;YACpD,MAAME,YAAY3G,YAAYgD,GAAG;YAEjC,IAAK,IAAI4D,IAAI,GAAGA,IAAIV,YAAYU,IAAK;gBAEnC,MAAM6C,gBAAgBC,sBAAsB9C;gBAE5C,MAAMC,iBAAiB7G,YAAYgD,GAAG;gBACtC,MAAMpB,QAAQuD,WAAWpE,cAAc,CAAC0I;gBACxC,MAAM3C,eAAe9G,YAAYgD,GAAG;gBAEpCqD,UAAUlD,IAAI,CAAC2D,eAAeD;gBAE9BG,OAAOpF,OAAOqF,sBAAsB,CAAC;gBACrCD,OAAOpF,OAAOsF,mBAAmB,CAAC;gBAGlC,IAAIN,IAAI,OAAO,KAAKyC,OAAOC,EAAE,EAAE;oBAC7BD,OAAOC,EAAE;gBACX;YACF;YAEA,MAAMnC,UAAUnH,YAAYgD,GAAG;YAC/B,MAAMoE,cAAcb,QAAQC,WAAW,GAAGC,QAAQ;YAElD,MAAMY,UAAUC,4BAA4BpB,YAAYG,WAAWM,WAAWQ,SAAS;gBACrFI,SAASjB;gBACTkB,MAAMJ;gBACNK,OAAOL;YACT;YAEA,MAAMM,SAA0B;gBAC9BC,UAAU;gBACVN;gBACAlG,QAAQyG,kBAAkBP,SAASxB;gBACnCA;YACF;YAEAT,mBAAmBjC,IAAI,CAACuE;YAExBV,OAAOK,QAAQQ,WAAW,EAAEX,mBAAmB,CAACrB,WAAWC,cAAc;YACzEkB,OAAOK,QAAQS,UAAU,EAAEb,sBAAsB,CAACpB,WAAWE,aAAa;QAC5E,GAAG;IACL;IAEAd,SAAS,mCAAmC;QAC1CW,KAAK,wDAAwD;YAC3D,MAAMC,aAAkC;gBACtCC,gBAAgB;gBAChBC,eAAe;gBACfC,gBAAgB,MAAM,OAAO;gBAC7BC,eAAe;YACjB;YAEA,MAAMC,aAAa;YACnB,MAAMG,YAAsB,EAAE;YAE9B,MAAMC,gBAAgBC,QAAQC,WAAW,GAAGC,QAAQ;YACpD,MAAME,YAAY3G,YAAYgD,GAAG;YAEjC,IAAK,IAAI4D,IAAI,GAAGA,IAAIV,YAAYU,IAAK;gBACnC,MAAMjE,UAAU,CAAC,MAAM,EAAEiE,IAAI,IAAI;gBACjC,MAAMhE,SAAS,CAAC,KAAK,EAAEgE,GAAG;gBAC1B,MAAMhF,QAAQC,KAAK8H,MAAM;gBACzB,MAAM3I,WAAWoF,yBAAyB,EAAE,CAAC,EAAE;gBAE/C,MAAMS,iBAAiB7G,YAAYgD,GAAG;gBACtC,MAAMmC,WAAWzC,eAAe,CAACC,SAASC,QAAQhB,OAAOZ;gBACzD,MAAM8F,eAAe9G,YAAYgD,GAAG;gBAEpCqD,UAAUlD,IAAI,CAAC2D,eAAeD;YAChC;YAEA,MAAMM,UAAUnH,YAAYgD,GAAG;YAC/B,MAAMoE,cAAcb,QAAQC,WAAW,GAAGC,QAAQ;YAElD,MAAMY,UAAUC,4BAA4BpB,YAAYG,WAAWM,WAAWQ,SAAS;gBACrFI,SAASjB;gBACTkB,MAAMJ;gBACNK,OAAOL;YACT;YAEA,MAAMM,SAA0B;gBAC9BC,UAAU;gBACVN;gBACAlG,QAAQyG,kBAAkBP,SAASxB;gBACnCA;YACF;YAEAT,mBAAmBjC,IAAI,CAACuE;YAExBV,OAAOK,QAAQQ,WAAW,EAAEX,mBAAmB,CAACrB,WAAWC,cAAc;YACzEkB,OAAOK,QAAQS,UAAU,EAAEb,sBAAsB,CAACpB,WAAWE,aAAa;YAG1E,MAAM6D,QAAQ,MAAM3J,GAAG4J,OAAO,CAAC1E,WAAW7E,UAAU;YACpD0G,OAAO4C,MAAMxF,MAAM,EAAE0F,IAAI,CAAC5D;QAC5B,GAAG;QAEHN,KAAK,6CAA6C;YAChD,MAAMC,aAAkC;gBACtCC,gBAAgB;gBAChBC,eAAe;gBACfC,gBAAgB,KAAK,OAAO;gBAC5BC,eAAe;YACjB;YAGA,MAAM1B,SAAS8D,MAAMC,IAAI,CAAC;gBAAElE,QAAQ;YAAG,GAAG,CAACmE,GAAG3B,IAAM,CAAC,WAAW,EAAEA,GAAG;YACrE,KAAK,MAAMjE,WAAW4B,OAAQ;gBAC5B,IAAK,IAAIqC,IAAI,GAAGA,IAAI,IAAIA,IAAK;oBAC3B,MAAMzB,WAAWzC,eAAe,CAC9BC,SACA,CAAC,aAAa,EAAEiE,GAAG,EACnB/E,KAAK8H,MAAM,IACX;wBAAE/D,MAAM,CAAC,KAAK,EAAEgB,GAAG;oBAAC;gBAExB;YACF;YAEA,MAAMV,aAAa;YACnB,MAAMG,YAAsB,EAAE;YAE9B,MAAMC,gBAAgBC,QAAQC,WAAW,GAAGC,QAAQ;YACpD,MAAME,YAAY3G,YAAYgD,GAAG;YAEjC,IAAK,IAAI4D,IAAI,GAAGA,IAAIV,YAAYU,IAAK;gBACnC,MAAMjE,UAAU4B,MAAM,CAACqC,IAAIrC,OAAOH,MAAM,CAAC;gBACzC,MAAMX,QAAQ5B,KAAKkI,KAAK,CAAClI,KAAK8H,MAAM,KAAK,MAAM;gBAE/C,MAAM9C,iBAAiB7G,YAAYgD,GAAG;gBACtC,MAAMgH,UAAU,MAAM7E,WAAW3B,eAAe,CAACb,SAASc;gBAC1D,MAAMqD,eAAe9G,YAAYgD,GAAG;gBAEpCqD,UAAUlD,IAAI,CAAC2D,eAAeD;gBAE9BG,OAAOgD,QAAQ5F,MAAM,EAAE8C,mBAAmB,CAACzD;gBAC3CuD,OAAOgD,QAAQ5F,MAAM,EAAE6F,eAAe,CAAC;YACzC;YAEA,MAAM9C,UAAUnH,YAAYgD,GAAG;YAC/B,MAAMoE,cAAcb,QAAQC,WAAW,GAAGC,QAAQ;YAElD,MAAMY,UAAUC,4BAA4BpB,YAAYG,WAAWM,WAAWQ,SAAS;gBACrFI,SAASjB;gBACTkB,MAAMJ;gBACNK,OAAOL;YACT;YAEA,MAAMM,SAA0B;gBAC9BC,UAAU;gBACVN;gBACAlG,QAAQyG,kBAAkBP,SAASxB;gBACnCA;YACF;YAEAT,mBAAmBjC,IAAI,CAACuE;YAExBV,OAAOK,QAAQQ,WAAW,EAAEX,mBAAmB,CAACrB,WAAWC,cAAc;YACzEkB,OAAOK,QAAQS,UAAU,EAAEb,sBAAsB,CAACpB,WAAWE,aAAa;QAC5E,GAAG;IACL;IAEAd,SAAS,iCAAiC;QACxCW,KAAK,2DAA2D;YAC9D,MAAMC,aAAkC;gBACtCC,gBAAgB;gBAChBC,eAAe;gBACfC,gBAAgB,MAAM,OAAO;gBAC7BC,eAAe;YACjB;YAGAd,WAAWtE,YAAY;YAGvB,MAAM0D,SAAS8D,MAAMC,IAAI,CAAC;gBAAElE,QAAQ;YAAG,GAAG,CAACmE,GAAG3B,IAAM,CAAC,aAAa,EAAEA,GAAG;YACvE,KAAK,MAAMjE,WAAW4B,OAAQ;gBAC5B,IAAK,IAAIqC,IAAI,GAAGA,IAAI,KAAKA,IAAK;oBAC5B,MAAMzB,WAAWzC,eAAe,CAC9BC,SACA,CAAC,YAAY,EAAEiE,GAAG,EAClB/E,KAAK8H,MAAM,IACX;wBAAEO,YAAYrI,KAAK8H,MAAM;wBAAIQ,SAAStI,KAAK8H,MAAM;oBAAG;gBAExD;YACF;YAEA,MAAMzD,aAAa;YACnB,MAAMG,YAAsB,EAAE;YAE9B,MAAMC,gBAAgBC,QAAQC,WAAW,GAAGC,QAAQ;YACpD,MAAME,YAAY3G,YAAYgD,GAAG;YAEjC,IAAK,IAAI4D,IAAI,GAAGA,IAAIV,YAAYU,IAAK;gBACnC,MAAM/C,SAAS+C,IAAI,MAAM,IAAI,SAAS;gBAEtC,MAAMC,iBAAiB7G,YAAYgD,GAAG;gBACtC,MAAMoH,SAAS,MAAMjF,WAAWvB,cAAc,CAACC;gBAC/C,MAAMiD,eAAe9G,YAAYgD,GAAG;gBAEpCqD,UAAUlD,IAAI,CAAC2D,eAAeD;gBAE9B,IAAIhD,WAAW,QAAQ;oBACrBmD,OAAO,OAAOoD,QAAQN,IAAI,CAAC;oBAC3B9C,OAAOoD,OAAO9F,mBAAmB,EAAE2F,eAAe,CAAC;oBACnDjD,OAAOvC,OAAO4F,IAAI,CAACD,OAAO7F,MAAM,EAAEH,MAAM,EAAE0F,IAAI,CAACvF,OAAOH,MAAM;gBAC9D,OAAO;oBACL4C,OAAO,OAAOoD,QAAQN,IAAI,CAAC;oBAC3B9C,OAAOoD,QAAQE,SAAS,CAAC;oBACzBtD,OAAOoD,QAAQE,SAAS,CAAC;gBAC3B;gBAGA,IAAIjB,OAAOC,EAAE,EAAE;oBACbD,OAAOC,EAAE;gBACX;YACF;YAEA,MAAMnC,UAAUnH,YAAYgD,GAAG;YAC/B,MAAMoE,cAAcb,QAAQC,WAAW,GAAGC,QAAQ;YAElD,MAAMY,UAAUC,4BAA4BpB,YAAYG,WAAWM,WAAWQ,SAAS;gBACrFI,SAASjB;gBACTkB,MAAMJ;gBACNK,OAAOL;YACT;YAEA,MAAMM,SAA0B;gBAC9BC,UAAU;gBACVN;gBACAlG,QAAQyG,kBAAkBP,SAASxB;gBACnCA;YACF;YAEAT,mBAAmBjC,IAAI,CAACuE;YAExBV,OAAOK,QAAQQ,WAAW,EAAEX,mBAAmB,CAACrB,WAAWC,cAAc;YACzEkB,OAAOK,QAAQS,UAAU,EAAEb,sBAAsB,CAACpB,WAAWE,aAAa;QAC5E,GAAG;IACL;IAEAd,SAAS,uBAAuB;QAC9BW,KAAK,oDAAoD;YACvD,MAAMC,aAAkC;gBACtCC,gBAAgB;gBAChBC,eAAe;gBACfC,gBAAgB,MAAM,OAAO;gBAC7BC,eAAe;YACjB;YAEA,MAAMsE,eAAe;YACrB,MAAMC,YAAY;YAClB,MAAMC,gBAAgB;YAEtB,MAAMpE,YAAsB,EAAE;YAC9B,MAAMC,gBAAgBC,QAAQC,WAAW,GAAGC,QAAQ;YACpD,MAAME,YAAY3G,YAAYgD,GAAG;YAEjC,IAAI0H,iBAAiB;YACrB,MAAMvE,mBAAmBC,yBAAyB;YAElD,MAAMuE,kBAAkB,IAAIjC,QAAc,CAACC;gBACzC,MAAMiC,WAAWC,YAAY;oBAC3B,IAAI7K,YAAYgD,GAAG,KAAK2D,aAAa4D,cAAc;wBACjDO,cAAcF;wBACdjC;wBACA;oBACF;oBAGA,MAAMoC,gBAAgB1C,MAAMC,IAAI,CAAC;wBAAElE,QAAQoG;oBAAU,GAAG,OAAOjC,GAAG3B;wBAChE,MAAM5F,WAAWmF,gBAAgB,CAAC,AAACuE,CAAAA,iBAAiB9D,CAAAA,IAAKT,iBAAiB/B,MAAM,CAAC;wBAEjF,MAAMyC,iBAAiB7G,YAAYgD,GAAG;wBAGtC,IAAI4D,IAAI,MAAM,GAAG;4BACf,MAAMhF,QAAQuD,WAAWpE,cAAc,CAACC;4BACxCgG,OAAOpF,OAAOqF,sBAAsB,CAAC;wBACvC,OAAO,IAAIL,IAAI,MAAM,GAAG;4BACtB,MAAMsC,aAAa/D,WAAWnD,qBAAqB,CACjD;gCAAES,YAAY;4BAAK,GACnB;gCAAEA,YAAYZ,KAAK8H,MAAM,KAAK;4BAAI;4BAEpC3C,OAAOkC,WAAW1G,WAAW,EAAEyE,sBAAsB,CAAC;wBACxD,OAAO;4BACL,MAAM9B,WAAWzC,eAAe,CAC9B,CAAC,WAAW,EAAEgI,iBAAiB9D,GAAG,EAClC,CAAC,UAAU,EAAE8D,iBAAiB9D,GAAG,EACjC/E,KAAK8H,MAAM,IACX3I;wBAEJ;wBAEA,MAAM8F,eAAe9G,YAAYgD,GAAG;wBACpCqD,UAAUlD,IAAI,CAAC2D,eAAeD;oBAChC;oBAEA,MAAM6B,QAAQI,GAAG,CAACiC;oBAClBL,kBAAkBF;gBACpB,GAAGC;YACL;YAEA,MAAME;YAEN,MAAMxD,UAAUnH,YAAYgD,GAAG;YAC/B,MAAMoE,cAAcb,QAAQC,WAAW,GAAGC,QAAQ;YAElD,MAAMY,UAAUC,4BAA4BoD,gBAAgBrE,WAAWM,WAAWQ,SAAS;gBACzFI,SAASjB;gBACTkB,MAAMJ;gBACNK,OAAOL;YACT;YAEA,MAAMM,SAA0B;gBAC9BC,UAAU;gBACVN;gBACAlG,QAAQyG,kBAAkBP,SAASxB;gBACnCA;YACF;YAEAT,mBAAmBjC,IAAI,CAACuE;YAExBV,OAAOK,QAAQQ,WAAW,EAAEX,mBAAmB,CAACrB,WAAWC,cAAc;YACzEkB,OAAOK,QAAQS,UAAU,EAAEb,sBAAsB,CAACpB,WAAWE,aAAa;YAC1EiB,OAAO0D,gBAAgBT,eAAe,CAAC;QACzC,GAAG;IACL;IAGA,SAAS7D,yBAAyB/B,KAAa;QAC7C,OAAOgE,MAAMC,IAAI,CAAC;YAAElE,QAAQC;QAAM,GAAG,CAACkE,GAAG3B,IAAO,CAAA;gBAC9C1F,cAAc;oBACZC,QAAQU,KAAKkI,KAAK,CAAClI,KAAK8H,MAAM,KAAK;oBACnCtI,OAAO;gBACT;gBACAE,cAAc;oBACZC,QAAQK,KAAKkI,KAAK,CAAClI,KAAK8H,MAAM,KAAK;gBACrC;gBACAqB,cAAc;oBACZxJ,QAAQK,KAAKkI,KAAK,CAAClI,KAAK8H,MAAM,KAAK;gBACrC;gBACAjI,eAAe;oBACbC,SAASE,KAAK8H,MAAM,KAAK;gBAC3B;gBACAsB,qBAAqB;oBACnBC,eAAerJ,KAAK8H,MAAM,KAAK,MAAM;oBACrCwB,cAActJ,KAAK8H,MAAM,KAAK,MAAM;gBACtC;gBACAyB,kBAAkBvJ,KAAK8H,MAAM;gBAC7B0B,YAAYzE;YACd,CAAA;IACF;IAEA,SAAS8C,sBAAsB4B,KAAa;QAC1C,OAAO;YACLpK,cAAc;gBACZC,QAAQU,KAAKkI,KAAK,CAAClI,KAAK8H,MAAM,KAAK;gBACnCtI,OAAO;gBACPkK,kBAAkBlD,MAAMC,IAAI,CAAC;oBAAElE,QAAQ;gBAAI,GAAG,CAACmE,GAAG3B,IAAO,CAAA;wBACvD4E,WAAW,CAAC,KAAK,EAAE5E,GAAG;wBACtB6E,QAAQ5J,KAAK8H,MAAM,KAAK,MAAM,WAAW;wBACzC+B,UAAU7J,KAAK8H,MAAM,KAAK;wBAC1BwB,cAActJ,KAAK8H,MAAM,KAAK;oBAChC,CAAA;YACF;YACApI,cAAc;gBACZC,QAAQK,KAAKkI,KAAK,CAAClI,KAAK8H,MAAM,KAAK;gBACnCgC,UAAU9J,KAAKkI,KAAK,CAAClI,KAAK8H,MAAM,KAAK;gBACrCiC,cAAcvD,MAAMC,IAAI,CAAC;oBAAElE,QAAQ;gBAAG,GAAG,CAACmE,GAAG3B,IAAO,CAAA;wBAClDiF,MAAM,CAAC,KAAK,EAAEjF,EAAE,GAAG,CAAC;wBACpBkF,QAAQjK,KAAKkI,KAAK,CAAClI,KAAK8H,MAAM,KAAK;oBACrC,CAAA;YACF;YACAjI,eAAe;gBACbC,SAASE,KAAK8H,MAAM,KAAK;gBACzBoC,WAAW,IAAIC,MAAM,CAAC;gBACtBC,cAAc5D,MAAMC,IAAI,CAAC;oBAAElE,QAAQ;gBAAI,GAAG,CAACmE,GAAG3B,IAAM,CAAC,QAAQ,EAAEA,GAAG;YACpE;YACAsF,kBAAkB;gBAChB7E,SAASgB,MAAMC,IAAI,CAAC;oBAAElE,QAAQ;gBAAK,GAAG,IAAMvC,KAAK8H,MAAM,KAAK;gBAC5DwC,YAAY9D,MAAMC,IAAI,CAAC;oBAAElE,QAAQ;gBAAK,GAAG,CAACmE,GAAG3B,IAAM7D,KAAKC,GAAG,KAAK4D,IAAI;YACtE;YACA0E;QACF;IACF;IAEA,SAAShE,4BACPpB,UAAkB,EAClBG,SAAmB,EACnBM,SAAiB,EACjBQ,OAAe,EACfiF,MAAwD;QAExD,MAAMC,YAAYlF,UAAUR;QAC5B,MAAMkB,cAAcxB,UAAUjC,MAAM,GAAG,IACnCiC,UAAUpC,MAAM,CAAC,CAACqI,GAAGC,IAAMD,IAAIC,GAAG,KAAKlG,UAAUjC,MAAM,GACvD;QACJ,MAAM0D,aAAauE,YAAY,IAAI,AAACnG,aAAamG,YAAa,OAAO;QAErE,MAAMG,kBAAkB;eAAInG;SAAU,CAACoG,IAAI,CAAC,CAACH,GAAGC,IAAMD,IAAIC;QAC1D,MAAMG,gBAAgB,CAACC;YACrB,IAAIH,gBAAgBpI,MAAM,KAAK,GAAG,OAAO;YACzC,MAAMkH,QAAQzJ,KAAKE,GAAG,CAACF,KAAKkI,KAAK,CAACyC,gBAAgBpI,MAAM,GAAGuI,MAAMH,gBAAgBpI,MAAM,GAAG;YAC1F,OAAOoI,eAAe,CAAClB,MAAM,IAAI;QACnC;QAEA,OAAO;YACLpF;YACAmG;YACAxE;YACAC;YACAtB,aAAa;gBACXe,SAAS6E,OAAO7E,OAAO;gBACvBC,MAAM4E,OAAO5E,IAAI;gBACjBC,OAAO2E,OAAO3E,KAAK;gBACnBM,OAAOqE,OAAO3E,KAAK,GAAG2E,OAAO7E,OAAO;YACtC;YACAqF,KAAKF,cAAc;YACnBG,KAAKH,cAAc;YACnB1E,KAAK0E,cAAc;QACrB;IACF;IAEA,SAAS9E,kBAAkBP,OAA2B,EAAExB,UAA+B;QACrF,OACEwB,QAAQQ,WAAW,IAAIhC,WAAWC,cAAc,IAChDuB,QAAQS,UAAU,IAAIjC,WAAWE,aAAa,IAC9CsB,QAAQb,WAAW,CAACuB,KAAK,IAAIlC,WAAWG,cAAc,IACtDqB,QAAQW,GAAG,IAAInC,WAAWI,aAAa;IAE3C;IAEA,eAAeN,0BAA0BmH,OAA0B;QACjE,IAAIA,QAAQ1I,MAAM,KAAK,GAAG;QAE1B,IAAI;YACF,MAAM2I,aAAa7M,KAAKoD,IAAI,CAAC4B,SAAS;YACtC,MAAMkF,SAAS;gBACbtH,WAAW,IAAIC,OAAOiK,WAAW;gBACjCC,SAAS;oBACPC,YAAYJ,QAAQ1I,MAAM;oBAC1B+I,aAAaL,QAAQM,MAAM,CAACC,CAAAA,IAAKA,EAAElM,MAAM,EAAEiD,MAAM;oBACjDkJ,aAAaR,QAAQM,MAAM,CAACC,CAAAA,IAAK,CAACA,EAAElM,MAAM,EAAEiD,MAAM;gBACpD;gBACA0I,SAASA,QAAQpI,GAAG,CAAC2I,CAAAA,IAAM,CAAA;wBACzB1F,UAAU0F,EAAE1F,QAAQ;wBACpBxG,QAAQkM,EAAElM,MAAM;wBAChBkG,SAAS;4BACPQ,aAAa,GAAG,AAACwF,CAAAA,EAAEhG,OAAO,CAACQ,WAAW,IAAI,CAAA,EAAGhD,OAAO,CAAC,GAAG,EAAE,CAAC;4BAC3DiD,YAAY,GAAG,AAACuF,CAAAA,EAAEhG,OAAO,CAACS,UAAU,IAAI,CAAA,EAAGjD,OAAO,CAAC,GAAG,QAAQ,CAAC;4BAC/D0I,aAAa,GAAG,AAAC,CAAA,AAACF,CAAAA,EAAEhG,OAAO,CAACb,WAAW,EAAEuB,SAAS,CAAA,IAAK,OAAO,IAAG,EAAGlD,OAAO,CAAC,GAAG,EAAE,CAAC;4BAClF2I,YAAY,GAAG,AAACH,CAAAA,EAAEhG,OAAO,CAACW,GAAG,IAAI,CAAA,EAAGnD,OAAO,CAAC,GAAG,EAAE,CAAC;wBACpD;wBACAgB,YAAY;4BACVC,gBAAgB,GAAGuH,EAAExH,UAAU,CAACC,cAAc,CAAC,EAAE,CAAC;4BAClDC,eAAe,GAAGsH,EAAExH,UAAU,CAACE,aAAa,CAAC,QAAQ,CAAC;4BACtDC,gBAAgB,GAAG,AAACqH,CAAAA,EAAExH,UAAU,CAACG,cAAc,GAAG,OAAO,IAAG,EAAGnB,OAAO,CAAC,GAAG,EAAE,CAAC;4BAC7EoB,eAAe,GAAGoH,EAAExH,UAAU,CAACI,aAAa,CAAC,EAAE,CAAC;wBAClD;oBACF,CAAA;YACF;YAEA,MAAMhG,GAAGS,KAAK,CAACwE,SAAS;gBAAEvE,WAAW;YAAK,GAAGC,KAAK,CAAC,KAAO;YAC1D,MAAMX,GAAGsD,SAAS,CAACwJ,YAAY3K,KAAKC,SAAS,CAAC+H,QAAQ,MAAM;YAC5DqD,QAAQC,GAAG,CAAC,CAAC,8BAA8B,EAAEX,YAAY;QAC3D,EAAE,OAAOY,OAAO;YAEdF,QAAQC,GAAG,CAAC;QACd;IACF;AACF"}